<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analizzatore Vendite - COMPLETO FUNZIONANTE</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- jsPDF library for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-width: 1400px;
            margin: 0 auto;
        }
        h1, h2 {
            color: #333;
            text-align: center;
        }

        /* Tabs */
        .tabs {
            display: flex;
            border-bottom: 3px solid #4CAF50;
            margin: 20px 0;
        }
        .tab {
            padding: 12px 24px;
            cursor: pointer;
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-bottom: none;
            margin-right: 5px;
            border-radius: 8px 8px 0 0;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        .tab.active {
            background: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }
        .tab:hover:not(.active) {
            background: #e8f5e8;
        }

        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }

        .upload-section {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
        }
        .file-upload input[type=file] {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }
        .debug {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 15px;
            margin: 20px 0;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }

        /* Custom Rates Table */
        .rates-section {
            margin: 30px 0;
        }
        .rates-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .rates-controls input, .rates-controls select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .rates-table-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .rates-table {
            width: 100%;
            border-collapse: collapse;
        }
        .rates-table th {
            background: #4CAF50;
            color: white;
            padding: 12px;
            text-align: left;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        .rates-table td {
            padding: 10px;
            border-bottom: 1px solid #eee;
        }
        .rates-table input[type="number"] {
            width: 80px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
            text-align: center;
        }
        .rates-table input[type="number"]:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 5px rgba(76, 175, 80, 0.3);
        }
        .custom-rate {
            background: #fff3cd !important;
            border-left: 4px solid #ffc107 !important;
        }

        .shop-configured {
            background: #d4edda !important;
            border-left: 4px solid #28a745 !important;
        }
        .shop-unconfigured {
            background: #f8d7da !important;
            border-left: 4px solid #dc3545 !important;
        }
        .shop-found-in-csv {
            background: #d1ecf1 !important;
            border-left: 4px solid #17a2b8 !important;
        }

        .status-badge {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
        }
        .status-configured {
            background: #28a745;
            color: white;
        }
        .status-unconfigured {
            background: #dc3545;
            color: white;
        }
        .status-found {
            background: #17a2b8;
            color: white;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .control-group label {
            font-weight: bold;
            display: block;
            margin-bottom: 5px;
        }
        .control-group input, .control-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .btn {
            background: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        .btn:hover {
            background: #45a049;
            transform: translateY(-1px);
        }
        .btn-secondary {
            background: #6c757d;
        }
        .btn-secondary:hover {
            background: #5a6268;
        }
        .btn-expand {
            background: #2196F3;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin: 10px;
        }

        /* Stats Cards */
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        .stat-card {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            padding: 12px;
            border-radius: 6px;
            text-align: center;
            transition: transform 0.2s ease;
            position: relative;
            cursor: help;
        }
        .stat-card:hover {
            transform: translateY(-2px);
        }
        .stat-value {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 3px;
        }
        .stat-label {
            font-size: 11px;
            opacity: 0.9;
            line-height: 1.2;
        }
        .stat-card .tooltip {
            visibility: hidden;
            background-color: rgba(0,0,0,0.9);
            color: white;
            text-align: left;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            width: 200px;
            font-size: 11px;
            line-height: 1.3;
        }
        .stat-card:hover .tooltip {
            visibility: visible;
        }

        /* Pivot Table - Same as before */
        .pivot-container {
            margin: 30px 0;
        }
        .shop-row {
            background: #f8f9ff;
            border: 2px solid #e1e7ff;
            border-radius: 8px;
            margin: 10px 0;
            overflow: hidden;
        }
        .shop-header {
            padding: 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, #f0f4ff, #e8f0ff);
            transition: background 0.3s ease;
        }
        .shop-header:hover {
            background: linear-gradient(135deg, #e8f0ff, #dde7ff);
        }
        .shop-info {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        .shop-name {
            font-size: 20px;
            font-weight: bold;
            color: #2c5aa0;
        }
        .shop-summary {
            font-size: 14px;
            color: #666;
        }
        .shop-metrics {
            display: flex;
            gap: 30px;
            text-align: center;
        }
        .shop-metric {
            display: flex;
            flex-direction: column;
        }
        .shop-metric-value {
            font-size: 16px;
            font-weight: bold;
            color: #4CAF50;
        }
        .shop-metric-label {
            font-size: 12px;
            color: #666;
        }

        /* Comparison Mode Styles */
        .comparison-metrics {
            display: flex;
            gap: 20px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        .period-comparison {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 12px;
            border-radius: 6px;
            min-width: 120px;
        }

        .period-comparison:first-child {
            background: rgba(227, 242, 253, 0.3);
            border: 1px solid #e3f2fd;
        }

        .period-comparison:nth-child(2) {
            background: rgba(255, 243, 224, 0.3);
            border: 1px solid #fff3e0;
        }

        .period-label {
            font-size: 11px;
            font-weight: bold;
            color: #1a1a1a;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .period-values {
            display: flex;
            flex-direction: column;
            text-align: center;
            gap: 2px;
        }

        .period-values div {
            font-size: 13px;
            font-weight: bold;
            color: #1a1a1a;
        }

        /* Ensure better contrast for period labels */
        .period-comparison:first-child .period-label {
            color: #0d47a1;
            font-weight: 900;
        }

        .period-comparison:nth-child(2) .period-label {
            color: #bf360c;
            font-weight: 900;
        }

        .period-comparison:first-child .period-values div {
            color: #0d47a1;
        }

        .period-comparison:nth-child(2) .period-values div {
            color: #bf360c;
        }

        .growth-indicators {
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: center;
            padding: 8px;
            border-radius: 6px;
            background: rgba(248, 249, 250, 0.5);
            border: 1px solid #dee2e6;
        }

        .growth-metric {
            font-size: 12px;
            font-weight: bold;
            text-align: center;
            display: flex;
            align-items: center;
            gap: 2px;
        }

        .significant-change {
            background: rgba(255, 235, 59, 0.1) !important;
            border-left: 3px solid #ff9800 !important;
        }

        .comparison-mode .shop-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .comparison-mode .shop-name {
            color: white;
        }

        .comparison-mode .shop-summary {
            color: rgba(255, 255, 255, 0.8);
        }

        .comparison-mode .expand-icon {
            color: white;
        }

        /* Responsive comparison mode */
        @media (max-width: 768px) {
            .comparison-metrics {
                flex-direction: column;
                gap: 10px;
            }

            .period-comparison {
                min-width: 100px;
            }
        }

        /* Timeline Mode Styles */
        .timeline-summary {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        .timeline-metric {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 12px;
            background: rgba(248, 249, 250, 0.5);
            border-radius: 6px;
            border: 1px solid #dee2e6;
        }

        .timeline-value {
            font-size: 14px;
            font-weight: bold;
            color: #333;
        }

        .timeline-label {
            font-size: 11px;
            color: #666;
            margin-top: 2px;
        }

        .timeline-trend {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 12px;
            background: rgba(248, 249, 250, 0.5);
            border-radius: 6px;
            border: 1px solid #dee2e6;
        }

        .trend-indicator {
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .timeline-mode .shop-header {
            background: linear-gradient(135deg, #4A90E2 0%, #5B9BD5 100%);
            color: white;
        }

        .timeline-mode .shop-name {
            color: white;
        }

        .timeline-mode .shop-summary {
            color: rgba(255, 255, 255, 0.9);
        }

        .timeline-mode .expand-icon {
            color: white;
        }

        .timeline-chart-container {
            background: #f8f9fa;
            padding: 15px;
            margin: 15px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .mini-chart {
            display: flex;
            align-items: end;
            justify-content: center;
            gap: 8px;
            height: 120px;
            padding: 20px;
            background: white;
            border-radius: 6px;
            margin: 10px 0;
        }

        .chart-bar {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 30px;
        }

        .chart-column {
            background: linear-gradient(to top, #4A90E2, #5B9BD5);
            width: 24px;
            border-radius: 3px 3px 0 0;
            min-height: 5px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .chart-column:hover {
            background: linear-gradient(to top, #357ABD, #4682B4);
            transform: scaleY(1.1);
        }

        .chart-label {
            font-size: 10px;
            color: #666;
            margin-top: 5px;
            text-align: center;
            transform: rotate(-45deg);
            transform-origin: center;
        }

        /* Prediction visualization styles */
        .prediction-column {
            animation: pulse-prediction 2s infinite;
        }

        @keyframes pulse-prediction {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        .prediction-label {
            color: #495057 !important;
            font-weight: bold;
        }

        .prediction-bar {
            position: relative;
        }

        .prediction-bar::before {
            content: "📈";
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 8px;
        }

        .prediction-info {
            border-left: 4px solid #007bff;
        }

        /* Timeline responsive */
        @media (max-width: 768px) {
            .timeline-summary {
                flex-direction: column;
                gap: 10px;
            }

            .mini-chart {
                gap: 4px;
                padding: 15px 10px;
            }

            .chart-bar {
                min-width: 20px;
            }

            .chart-column {
                width: 18px;
            }

            .chart-label {
                font-size: 9px;
            }
        }
        .expand-icon {
            font-size: 20px;
            transition: transform 0.3s ease;
            color: #4CAF50;
        }
        .shop-row.expanded .expand-icon {
            transform: rotate(90deg);
        }

        /* Operators Table */
        .operators-table {
            display: none;
            background: white;
            border-top: 1px solid #e1e7ff;
        }
        .shop-row.expanded .operators-table {
            display: block;
        }
        .operators-table table {
            width: 100%;
            border-collapse: collapse;
        }
        .operators-table th {
            background: #5a67d8;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: bold;
        }
        .operators-table td {
            padding: 12px;
            border-bottom: 1px solid #f0f0f0;
        }
        .operators-table tr:hover td {
            background-color: #f8f9fa;
        }

        /* Operator Rankings */
        .operator-rank-1 {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 237, 78, 0.3)) !important;
            border-left: 4px solid #ffd700 !important;
            font-weight: bold;
        }
        .operator-rank-2 {
            background: linear-gradient(135deg, rgba(192, 192, 192, 0.3), rgba(211, 211, 211, 0.3)) !important;
            border-left: 4px solid #c0c0c0 !important;
            font-weight: bold;
        }
        .operator-rank-3 {
            background: linear-gradient(135deg, rgba(205, 127, 50, 0.3), rgba(228, 155, 80, 0.3)) !important;
            border-left: 4px solid #cd7f32 !important;
            font-weight: bold;
        }

        .currency {
            text-align: right;
            font-family: 'Courier New', monospace;
        }
        .percentage {
            text-align: right;
            color: #2196F3;
            font-family: 'Courier New', monospace;
        }
        .text-center { text-align: center; }
        .hidden { display: none; }

        /* Search */
        .search-bar {
            margin: 20px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            display: flex;
            gap: 15px;
            align-items: center;
        }
        .search-bar input {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .search-bar select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .shop-header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }
            .shop-metrics {
                flex-direction: column;
                gap: 10px;
            }
            .controls {
                grid-template-columns: 1fr;
            }
            .stats {
                grid-template-columns: repeat(2, 1fr);
            }
            .tabs {
                flex-direction: column;
            }
            .tab {
                margin-right: 0;
                margin-bottom: 2px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>📊 Analizzatore Vendite - Percentuali Personalizzate</h1>

        <!-- Tabs -->
        <div class="tabs">
            <div class="tab active" onclick="showTab('upload', event)">📁 Caricamento</div>
            <div class="tab" onclick="showTab('shops', event)">🏪 Negozi</div>
            <div class="tab" onclick="showTab('rates', event)">⚙️ Percentuali Custom</div>
            <div class="tab" onclick="showTab('results', event)">📊 Risultati</div>
        </div>

        <!-- Tab 1: Upload -->
        <div id="tab-upload" class="tab-content active">
            <div class="upload-section">
                <h3>Carica CSV</h3>
                <input type="file" id="csvFile" accept=".csv" />
            </div>
            <div id="debug" class="debug"></div>
        </div>

        <!-- Tab 2: Shops -->
        <div id="tab-shops" class="tab-content">
            <div class="rates-section">
                <h2>🏪 Configurazione Negozi</h2>

                <div class="rates-controls">
                    <button class="btn" onclick="loadDefaultShops()">📋 Carica Lista Default</button>
                    <button class="btn btn-secondary" onclick="clearAllShops()">🗑️ Pulisci Tutto</button>
                    <button class="btn" onclick="saveShops()">💾 Salva Configurazione</button>
                </div>

                <div class="rates-controls">
                    <label>🔍 Cerca Negozio:</label>
                    <input type="text" id="shopSearch" placeholder="Codice o nome..." style="flex: 1;" />

                    <label>Mostra:</label>
                    <select id="shopDisplayFilter">
                        <option value="all">Tutti i negozi</option>
                        <option value="configured">Solo configurati</option>
                        <option value="unconfigured">Solo da configurare</option>
                        <option value="found">Solo trovati nel CSV</option>
                    </select>

                    <button class="btn btn-secondary" onclick="clearShopFilters()">🗑️ Pulisci Filtri</button>
                </div>

                <div id="shopsTableContainer" class="rates-table-container hidden">
                    <table class="rates-table">
                        <thead>
                            <tr>
                                <th>🏷️ Codice</th>
                                <th>🏪 Nome Negozio</th>
                                <th>📊 Venduto CSV</th>
                                <th>👥 Operatori</th>
                                <th>📍 Status</th>
                                <th>🗑️ Azioni</th>
                            </tr>
                        </thead>
                        <tbody id="shopsTableBody"></tbody>
                    </table>
                </div>

                <div id="noShopDataMessage" class="text-center" style="padding: 40px; color: #666;">
                    Carica prima un file CSV per configurare i negozi
                </div>
            </div>
        </div>

        <!-- Tab 3: Custom Rates -->
        <div id="tab-rates" class="tab-content">
            <div class="rates-section">
                <h2>⚙️ Configura Percentuali Personalizzate</h2>

                <div class="rates-controls">
                    <label>Percentuale Default:</label>
                    <input type="number" id="defaultRate" value="0.78" step="0.01" min="0" max="100" />
                    <span>%</span>

                    <button class="btn btn-secondary" onclick="applyDefaultToAll()">📄 Applica Default a Tutti</button>
                    <button class="btn btn-secondary" onclick="resetCustomRates()">🔄 Reset</button>
                    <button class="btn" onclick="saveRates()">💾 Salva Configurazione</button>
                </div>

                <div class="rates-controls">
                    <label>🔍 Cerca Dipendente:</label>
                    <input type="text" id="employeeSearch" placeholder="Nome dipendente..." style="flex: 1;" />

                    <label>Filtra per Negozio:</label>
                    <select id="employeeShopFilter" style="min-width: 150px;">
                        <option value="">Tutti i negozi</option>
                    </select>

                    <label>Mostra solo:</label>
                    <select id="ratesFilter">
                        <option value="all">Tutti</option>
                        <option value="custom">Solo % Personalizzate</option>
                        <option value="default">Solo % Default</option>
                    </select>

                    <button class="btn btn-secondary" onclick="clearFilters()">🗑️ Pulisci Filtri</button>
                </div>

                <div id="ratesTableContainer" class="rates-table-container hidden">
                    <table class="rates-table">
                        <thead>
                            <tr>
                                <th>👤 Operatore</th>
                                <th>🏪 Negozio</th>
                                <th>💰 Venduto Totale (€)</th>
                                <th>⚙️ % Personalizzata</th>
                                <th>🏆 Provvigioni con Default</th>
                                <th>🏆 Provvigioni Custom</th>
                                <th>📊 Differenza</th>
                            </tr>
                        </thead>
                        <tbody id="ratesTableBody"></tbody>
                    </table>
                </div>

                <div id="noDataMessage" class="text-center" style="padding: 40px; color: #666;">
                    Carica prima un file CSV per configurare le percentuali personalizzate
                </div>
            </div>
        </div>

        <!-- Tab 3: Results -->
        <div id="tab-results" class="tab-content">
            <div id="controls" class="controls hidden">
                <div class="control-group">
                    <label>Modalità Calcolo</label>
                    <select id="calculationMode">
                        <option value="default">Percentuale Default</option>
                        <option value="custom">Percentuali Personalizzate</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>📊 Modalità Analisi</label>
                    <select id="analysisMode" onchange="toggleAnalysisMode()">
                        <option value="single">Singolo Periodo</option>
                        <option value="compare">Confronta Periodi</option>
                        <option value="timeline">Timeline Evolution</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Filtra per Negozio</label>
                    <select id="shopFilter">
                        <option value="">Tutti i negozi</option>
                    </select>
                </div>
                <div class="control-group" id="singlePeriodGroup">
                    <label>📅 Filtra per Periodo</label>
                    <select id="periodFilter">
                        <option value="">Tutti i periodi</option>
                    </select>
                </div>
                <div class="control-group hidden" id="periodAGroup">
                    <label>📅 Periodo A (Base)</label>
                    <select id="periodFilterA">
                        <option value="">Seleziona periodo A</option>
                    </select>
                </div>
                <div class="control-group hidden" id="periodBGroup">
                    <label>📅 Periodo B (Confronto)</label>
                    <select id="periodFilterB">
                        <option value="">Seleziona periodo B</option>
                    </select>
                </div>
                <div class="control-group" id="seasonalityGroup" style="display: none;">
                    <label>🌱 Modello Stagionalità</label>
                    <div style="margin-top: 5px;">
                        <label style="display: block; font-weight: normal; margin-bottom: 8px;">
                            <input type="radio" name="seasonalityMode" value="fixed" checked style="margin-right: 8px;">
                            📊 Fattori Fissi (Moda Italiana)
                        </label>
                        <label style="display: block; font-weight: normal; margin-bottom: 8px;">
                            <input type="radio" name="seasonalityMode" value="dynamic" style="margin-right: 8px;">
                            🎯 Dinamico (dai tuoi dati)
                        </label>
                        <div id="seasonalityStatus" style="font-size: 11px; color: #666; margin-top: 5px;">
                            📊 Usando fattori fissi standard
                        </div>
                    </div>
                </div>
                <div class="control-group">
                    <label>&nbsp;</label>
                    <button class="btn" onclick="processData()">🔄 Calcola Risultati</button>
                </div>
            </div>

            <div id="results" class="hidden">
                <div class="stats" id="stats"></div>

                <div class="search-bar">
                    <input type="text" id="searchInput" placeholder="🔍 Cerca negozio o operatore..." />
                    <select id="sortSelect">
                        <option value="commission">Ordina per Provvigioni</option>
                        <option value="sales">Ordina per Vendite</option>
                        <option value="operators">Ordina per N° Operatori</option>
                        <option value="name">Ordina per Nome</option>
                    </select>
                    <button class="btn-expand" onclick="toggleAllShops()">📖 Espandi Tutto</button>
                    <button class="btn" onclick="exportToPDF()" style="background: #dc3545;">📄 Esporta PDF</button>
                </div>

                <div class="pivot-container" id="pivotContainer"></div>
            </div>
        </div>
    </div>

    <script>
        let rawData = [];
        let pivotData = [];
        let customRates = {};
        let shopNames = {};
        let shopTotalsForMapping = {};
        let allExpanded = false;
        let operatorTotals = {};

        // Default shop names (from user's list)
        const defaultShopNames = {
            '002': 'MARZOCCA',
            '008': 'VALMONTONE',
            '0012': 'ANTEGNATE',
            '0038': 'FRANCIACORTA',
            '0059': 'MILANO',
            '0040': 'MOLFETTA',
            '0043': 'MANTOVA',
            '0044': 'PESCARA',
            '0046': 'NOVENTA',
            '0049': 'CASTELGUELFO',
            '0050': 'CASTELROMANO',
            '0053': 'VALDICHIANA',
            '0057': 'BRUGNATO',
            '0061': 'MONDOVI',
            '0063': 'MARCIANISE',
            '0064': 'ENNA',
            '0066': 'BARBERINO',
            '0067': 'TORINO',
            '0069': 'ORIO',
            '0003': 'JESI'
        };

        // Load saved rates from localStorage
        function loadSavedRates() {
            const saved = localStorage.getItem('customCommissionRates');
            if (saved) {
                customRates = JSON.parse(saved);
            }
        }

        // Load saved shop names from localStorage
        function loadSavedShopNames() {
            const saved = localStorage.getItem('shopNames');
            if (saved) {
                shopNames = JSON.parse(saved);
            }
        }

        // Save rates to localStorage
        function saveRates() {
            localStorage.setItem('customCommissionRates', JSON.stringify(customRates));
            alert('✅ Configurazione salvata con successo!');
        }

        // Save shop names to localStorage
        function saveShops() {
            localStorage.setItem('shopNames', JSON.stringify(shopNames));
            alert('✅ Configurazione negozi salvata con successo!');
        }

        // Load default shop names
        function loadDefaultShops() {
            if (confirm('Caricare la lista default dei negozi? Questo sovrascriverà le configurazioni attuali.')) {
                shopNames = { ...defaultShopNames };
                buildShopsTable();
            }
        }

        // Clear all shop names
        function clearAllShops() {
            if (confirm('Cancellare tutti i nomi dei negozi configurati?')) {
                shopNames = {};
                buildShopsTable();
            }
        }

        // Build shops table
        function buildShopsTable() {
            const container = document.getElementById('shopsTableContainer');
            const tbody = document.getElementById('shopsTableBody');
            const noDataMessage = document.getElementById('noShopDataMessage');

            // Check if we have CSV data
            if (rawData.length === 0) {
                container.classList.add('hidden');
                noDataMessage.classList.remove('hidden');
                return;
            }

            // Get unique shops from CSV data
            const shopsInCSV = {};
            rawData.forEach(record => {
                const shop = record.codDep;
                if (!shopsInCSV[shop]) {
                    shopsInCSV[shop] = {
                        code: shop,
                        totalSales: 0,
                        operatorCount: new Set(),
                        transactions: 0
                    };
                }
                shopsInCSV[shop].totalSales += record.amount;
                shopsInCSV[shop].operatorCount.add(record.operatore);
                shopsInCSV[shop].transactions += 1;
            });

            // Convert operator sets to counts
            Object.values(shopsInCSV).forEach(shop => {
                shop.operatorCount = shop.operatorCount.size;
            });

            // Combine with all known shops (from defaults and saved)
            const allShops = {};

            // Add shops from CSV
            Object.values(shopsInCSV).forEach(shop => {
                allShops[shop.code] = shop;
            });

            // Add shops from default list that aren't in CSV
            Object.keys(defaultShopNames).forEach(code => {
                if (!allShops[code]) {
                    allShops[code] = {
                        code: code,
                        totalSales: 0,
                        operatorCount: 0,
                        transactions: 0
                    };
                }
            });

            // Add shops from saved configuration that aren't elsewhere
            Object.keys(shopNames).forEach(code => {
                if (!allShops[code]) {
                    allShops[code] = {
                        code: code,
                        totalSales: 0,
                        operatorCount: 0,
                        transactions: 0
                    };
                }
            });

            container.classList.remove('hidden');
            noDataMessage.classList.add('hidden');

            // Sort shops by code
            const sortedShops = Object.values(allShops).sort((a, b) => a.code.localeCompare(b.code));

            tbody.innerHTML = '';

            sortedShops.forEach(shop => {
                const configuredName = shopNames[shop.code] || '';
                const defaultName = defaultShopNames[shop.code] || '';
                const foundInCSV = shop.totalSales > 0;

                let statusClass = '';
                let statusText = '';
                let statusBadgeClass = '';

                if (configuredName) {
                    statusClass = 'shop-configured';
                    statusText = 'Configurato';
                    statusBadgeClass = 'status-configured';
                } else if (foundInCSV) {
                    statusClass = 'shop-found-in-csv';
                    statusText = 'Trovato nel CSV';
                    statusBadgeClass = 'status-found';
                } else {
                    statusClass = 'shop-unconfigured';
                    statusText = 'Da configurare';
                    statusBadgeClass = 'status-unconfigured';
                }

                const row = document.createElement('tr');
                row.className = statusClass;
                row.innerHTML = `
                    <td><strong>${shop.code}</strong></td>
                    <td>
                        <input type="text"
                               value="${configuredName || defaultName}"
                               placeholder="${defaultName || 'Inserisci nome...'}"
                               onchange="updateShopName('${shop.code}', this.value)"
                               style="width: 200px; padding: 5px; border: 1px solid #ddd; border-radius: 3px;" />
                    </td>
                    <td class="currency">
                        ${foundInCSV ? '€' + shop.totalSales.toLocaleString('it-IT', {minimumFractionDigits: 2}) : '-'}
                    </td>
                    <td class="text-center">
                        ${foundInCSV ? shop.operatorCount : '-'}
                    </td>
                    <td class="text-center">
                        <span class="status-badge ${statusBadgeClass}">${statusText}</span>
                    </td>
                    <td class="text-center">
                        ${configuredName || (foundInCSV && defaultName) ?
                            `<button onclick="deleteShop('${shop.code}')"
                                    style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;"
                                    title="Elimina negozio dalla configurazione">
                                🗑️ Elimina
                             </button>` :
                            '<span style="color: #999;">-</span>'
                        }
                    </td>
                `;

                tbody.appendChild(row);
            });
        }

        // Filter shops table
        function filterShopsTable() {
            const searchTerm = document.getElementById('shopSearch').value.toLowerCase();
            const displayFilter = document.getElementById('shopDisplayFilter').value;

            const tbody = document.getElementById('shopsTableBody');
            const rows = tbody.querySelectorAll('tr');

            let visibleRows = 0;

            rows.forEach(row => {
                const shopCode = row.cells[0].textContent.toLowerCase();
                const shopNameInput = row.cells[1].querySelector('input');
                const shopName = shopNameInput.value.toLowerCase();
                const hasStatusClass = row.classList.contains('shop-configured') ||
                                     row.classList.contains('shop-found-in-csv') ||
                                     row.classList.contains('shop-unconfigured');

                // Check search term
                const matchesSearch = searchTerm === '' ||
                                    shopCode.includes(searchTerm) ||
                                    shopName.includes(searchTerm);

                // Check display filter
                let matchesFilter = true;
                if (displayFilter === 'configured') {
                    matchesFilter = row.classList.contains('shop-configured');
                } else if (displayFilter === 'unconfigured') {
                    matchesFilter = row.classList.contains('shop-unconfigured');
                } else if (displayFilter === 'found') {
                    matchesFilter = row.classList.contains('shop-found-in-csv');
                }

                if (matchesSearch && matchesFilter) {
                    row.style.display = '';
                    visibleRows++;
                } else {
                    row.style.display = 'none';
                }
            });

            // Show/hide "no results" message for shops table
            const container = document.getElementById('shopsTableContainer');
            let noResultsMsg = container.querySelector('.no-shop-results-message');

            if (visibleRows === 0 && rows.length > 0) {
                if (!noResultsMsg) {
                    noResultsMsg = document.createElement('div');
                    noResultsMsg.className = 'no-shop-results-message';
                    noResultsMsg.style.cssText = 'text-align: center; padding: 40px; color: #666; font-style: italic;';
                    noResultsMsg.innerHTML = '🔍 Nessun negozio trovato con i filtri attuali';
                    container.appendChild(noResultsMsg);
                }
                noResultsMsg.style.display = 'block';
            } else if (noResultsMsg) {
                noResultsMsg.style.display = 'none';
            }
        }

        // Clear shop filters
        function clearShopFilters() {
            document.getElementById('shopSearch').value = '';
            document.getElementById('shopDisplayFilter').value = 'all';
            filterShopsTable();
        }

        // Update shop name
        function updateShopName(shopCode, newName) {
            if (newName.trim()) {
                shopNames[shopCode] = newName.trim();
            } else {
                delete shopNames[shopCode];
            }
            // Rebuild to update status
            buildShopsTable();
        }

        // Get display name for shop
        function getShopDisplayName(shopCode) {
            const name = shopNames[shopCode] || defaultShopNames[shopCode];
            return name ? `${shopCode}-${name}` : `Negozio ${shopCode}`;
        }

        // Delete shop from configuration
        function deleteShop(shopCode) {
            if (confirm(`Eliminare il negozio ${shopCode} dalla configurazione?\n\nQuesto rimuoverà solo la configurazione del nome, non i dati delle vendite.`)) {
                delete shopNames[shopCode];
                buildShopsTable();

                // Show confirmation message
                const container = document.getElementById('shopsTableContainer');
                const message = document.createElement('div');
                message.style.cssText = 'background: #d4edda; border: 1px solid #c3e6cb; color: #155724; padding: 10px; border-radius: 4px; margin: 10px 0; text-align: center;';
                message.innerHTML = `✅ Negozio ${shopCode} rimosso dalla configurazione`;
                container.parentNode.insertBefore(message, container);

                setTimeout(() => {
                    message.remove();
                }, 3000);
            }
        }

        // Toggle between analysis modes
        function toggleAnalysisMode() {
            const analysisMode = document.getElementById('analysisMode').value;
            const singleGroup = document.getElementById('singlePeriodGroup');
            const periodAGroup = document.getElementById('periodAGroup');
            const periodBGroup = document.getElementById('periodBGroup');
            const seasonalityGroup = document.getElementById('seasonalityGroup');

            if (analysisMode === 'compare') {
                singleGroup.classList.add('hidden');
                periodAGroup.classList.remove('hidden');
                periodBGroup.classList.remove('hidden');
                seasonalityGroup.style.display = 'none';

                // Populate comparison period selectors
                populateComparisonPeriods();
            } else if (analysisMode === 'timeline') {
                // Timeline mode - hide all period filters, show seasonality controls
                singleGroup.classList.add('hidden');
                periodAGroup.classList.add('hidden');
                periodBGroup.classList.add('hidden');
                seasonalityGroup.style.display = 'block';
            } else {
                // Single mode
                singleGroup.classList.remove('hidden');
                periodAGroup.classList.add('hidden');
                periodBGroup.classList.add('hidden');
                seasonalityGroup.style.display = 'none';
            }

            // Update seasonality status
            updateSeasonalityStatus();
        }

        // Global variable to store dynamic seasonality
        let dynamicSeasonalityFactors = null;

        // Update seasonality status display
        function updateSeasonalityStatus() {
            const statusDiv = document.getElementById('seasonalityStatus');
            const selectedMode = document.querySelector('input[name="seasonalityMode"]:checked')?.value || 'fixed';

            if (selectedMode === 'fixed') {
                statusDiv.innerHTML = '📊 Usando fattori fissi standard<br><small>Set: 0.88-1.10, Dic: 1.10</small>';
                statusDiv.style.color = '#666';
            } else {
                if (dynamicSeasonalityFactors) {
                    const periods = Object.keys(dynamicSeasonalityFactors).length;

                    // Show key months preview
                    const sept = dynamicSeasonalityFactors[9] ? dynamicSeasonalityFactors[9].toFixed(2) : 'N/A';
                    const dec = dynamicSeasonalityFactors[12] ? dynamicSeasonalityFactors[12].toFixed(2) : 'N/A';

                    statusDiv.innerHTML = `🎯 Fattori dinamici attivi (${periods} mesi)<br><small>Set: ${sept}, Dic: ${dec}</small>`;
                    statusDiv.style.color = '#28a745';
                } else {
                    statusDiv.innerHTML = '⚠️ Calcola prima i fattori dinamici';
                    statusDiv.style.color = '#dc3545';
                }
            }
        }

        // Calculate dynamic seasonality from historical data
        function calculateDynamicSeasonality(allData) {
            try {
                console.log('🔍 Calculating dynamic seasonality from historical data...');

                // Group data by month across all years and shops
                const monthlyData = {};
                let totalDataPoints = 0;

                allData.forEach(record => {
                    if (record.periodo && record.periodo !== 'SCONOSCIUTO' && record.amount > 0) {
                        const [year, month] = record.periodo.split('-');
                        const monthNum = parseInt(month);

                        if (!monthlyData[monthNum]) {
                            monthlyData[monthNum] = [];
                        }
                        monthlyData[monthNum].push(record.amount);
                        totalDataPoints++;
                    }
                });

                console.log(`📊 Found ${totalDataPoints} data points across ${Object.keys(monthlyData).length} months`);

                // Calculate average for each month
                const monthlyAverages = {};
                Object.keys(monthlyData).forEach(month => {
                    const monthSales = monthlyData[month];
                    monthlyAverages[month] = monthSales.reduce((sum, val) => sum + val, 0) / monthSales.length;
                });

                // Calculate overall average
                const overallAverage = Object.values(monthlyAverages).reduce((sum, val) => sum + val, 0) / Object.keys(monthlyAverages).length;

                // Calculate seasonal factors (month average / overall average)
                const seasonalFactors = {};
                Object.keys(monthlyAverages).forEach(month => {
                    let factor = monthlyAverages[month] / overallAverage;

                    // Apply smoothing and constraints (0.80 to 1.20 range)
                    factor = Math.max(0.80, Math.min(1.20, factor));

                    seasonalFactors[parseInt(month)] = parseFloat(factor.toFixed(3));
                });

                console.log('🎯 Dynamic seasonal factors calculated:', seasonalFactors);

                // Store globally
                dynamicSeasonalityFactors = seasonalFactors;

                return seasonalFactors;

            } catch (error) {
                console.error('❌ Error calculating dynamic seasonality:', error);
                return null;
            }
        }

        // Populate period selectors for comparison
        function populateComparisonPeriods() {
            const periodsFound = new Set();
            rawData.forEach(record => {
                if (record.periodo !== 'SCONOSCIUTO') {
                    periodsFound.add(record.periodo);
                }
            });

            const periodFilterA = document.getElementById('periodFilterA');
            const periodFilterB = document.getElementById('periodFilterB');

            periodFilterA.innerHTML = '<option value="">Seleziona periodo A</option>';
            periodFilterB.innerHTML = '<option value="">Seleziona periodo B</option>';

            const sortedPeriods = Array.from(periodsFound).sort();
            sortedPeriods.forEach(periodo => {
                const recordsCount = rawData.filter(r => r.periodo === periodo).length;
                const [year, month] = periodo.split('-');
                const monthNames = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu',
                                  'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'];
                const monthName = monthNames[parseInt(month) - 1] || month;
                const optionText = `${monthName} ${year} (${recordsCount} trans.)`;

                periodFilterA.innerHTML += `<option value="${periodo}">${optionText}</option>`;
                periodFilterB.innerHTML += `<option value="${periodo}">${optionText}</option>`;
            });
        }

        // Load saved data on page load
        loadSavedRates();
        loadSavedShopNames();

        // Tab functionality
        function showTab(tabName, event) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });

            // Show selected tab
            document.getElementById(`tab-${tabName}`).classList.add('active');
            if (event && event.target) {
                event.target.classList.add('active');
            }
        }

        // Add event listeners for seasonality mode changes
        document.addEventListener('DOMContentLoaded', function() {
            // File upload
            document.getElementById('csvFile').addEventListener('change', function(e) {
                console.log('🔍 CSV Upload Event Triggered');

                const file = e.target.files[0];
                if (!file) {
                    console.log('❌ No file selected');
                    return;
                }

                console.log('📁 File selected:', file.name, 'Size:', file.size, 'bytes');
                console.log('📄 File type:', file.type);

                const reader = new FileReader();

                reader.onerror = function(error) {
                    console.error('❌ FileReader error:', error);
                    document.getElementById('debug').textContent = 'Errore nella lettura del file: ' + error;
                };

                reader.onload = function(event) {
                    console.log('✅ File loaded successfully, length:', event.target.result.length);
                    const text = event.target.result;

                    if (!text || text.length === 0) {
                        console.log('❌ File is empty');
                        document.getElementById('debug').textContent = 'Il file è vuoto!';
                        return;
                    }

                    console.log('📊 Starting CSV parsing...');
                    parseCSV(text);
                };

                console.log('📖 Starting file read...');
                reader.readAsText(file, 'UTF-8');
            });
            // Listen for seasonality mode changes
            document.addEventListener('change', function(e) {
                if (e.target.name === 'seasonalityMode') {
                    updateSeasonalityStatus();

                    // If switching to dynamic mode and we have data, calculate factors
                    if (e.target.value === 'dynamic' && rawData.length > 0 && !dynamicSeasonalityFactors) {
                        calculateDynamicSeasonality(rawData);
                        updateSeasonalityStatus();
                    }

                    // Auto-refresh timeline results if in timeline mode (HOT SWAP)
                    const analysisMode = document.getElementById('analysisMode').value;
                    if (analysisMode === 'timeline' && window.isTimelineMode && pivotData.length > 0) {
                        console.log(`🔄 Hot-swapping to ${e.target.value.toUpperCase()} seasonality mode...`);
                        processTimelineData();
                        renderResults();
                    }
                }
            });

            // Search and sort functionality
            document.getElementById('searchInput').addEventListener('input', filterPivotTable);
            document.getElementById('sortSelect').addEventListener('change', sortPivotTable);

            // Employee search and filter functionality
            document.getElementById('employeeSearch').addEventListener('input', filterRatesTable);
            document.getElementById('employeeShopFilter').addEventListener('change', filterRatesTable);
            document.getElementById('ratesFilter').addEventListener('change', filterRatesTable);

            // Shop search and filter functionality
            document.getElementById('shopSearch').addEventListener('input', filterShopsTable);
            document.getElementById('shopDisplayFilter').addEventListener('change', filterShopsTable);
        });

        function parseCSV(text) {
            const debug = document.getElementById('debug');
            const lines = text.split('\n');

            let debugOutput = `File caricato: ${lines.length} righe\n\n`;

            rawData = [];

            // Same parsing logic as working version
            const firstDataLine = lines[1] || '';
            let separator = '';

            if (firstDataLine.includes(';')) {
                separator = ';';
                debugOutput += 'Separatore rilevato: punto e virgola (;)\n';
            } else if (firstDataLine.includes('\t')) {
                separator = '\t';
                debugOutput += 'Separatore rilevato: tab\n';
            } else {
                separator = 'spaces';
                debugOutput += 'Separatore rilevato: spazi multipli\n';
            }

            // Parse header
            let headers = [];
            if (separator === 'spaces') {
                headers = lines[0].split(/\s+/).filter(h => h.trim());
            } else {
                headers = lines[0].split(separator).map(h => h.trim());
            }

            // Find column indices
            const operatoreIndex = headers.findIndex(h =>
                h.toUpperCase().includes('OPERATORE') || h.toUpperCase() === 'OPERATORE'
            );
            const valNettoIndex = headers.findIndex(h =>
                h.toUpperCase().includes('VAL.NETTO') || h.toUpperCase().includes('NETTO')
            );
            const codDepIndex = headers.findIndex(h =>
                h.toUpperCase().includes('COD.DEP') || h.toUpperCase() === 'COD.DEP'
            );
            const dataIndex = headers.findIndex(h =>
                h.toUpperCase().includes('DATA') || h.toUpperCase() === 'DATA'
            );

            debugOutput += `Indici colonne:\n`;
            debugOutput += `OPERATORE: ${operatoreIndex} ("${headers[operatoreIndex] || 'NON TROVATO'}")\n`;
            debugOutput += `VAL.NETTO: ${valNettoIndex} ("${headers[valNettoIndex] || 'NON TROVATO'}")\n`;
            debugOutput += `COD.DEP: ${codDepIndex} ("${headers[codDepIndex] || 'NON TROVATO'}")\n`;
            debugOutput += `DATA: ${dataIndex} ("${headers[dataIndex] || 'NON TROVATO'}")\n\n`;

            if (operatoreIndex === -1 || valNettoIndex === -1) {
                debugOutput += '❌ ERRORE: Colonne OPERATORE o VAL.NETTO non trovate!\n';
                debug.textContent = debugOutput;
                return;
            }

            // Parse data
            let validRows = 0;
            const shops = new Set();

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                let columns = [];
                if (separator === 'spaces') {
                    columns = line.split(/\s+/).filter(c => c.trim());
                } else {
                    columns = line.split(separator).map(c => c.trim());
                }

                if (columns.length <= Math.max(operatoreIndex, valNettoIndex)) continue;

                const operatore = columns[operatoreIndex];
                const valNettoStr = columns[valNettoIndex];
                const codDep = codDepIndex >= 0 ? columns[codDepIndex] : 'N/A';
                const dataStr = dataIndex >= 0 ? columns[dataIndex] : '';

                if (!operatore || !valNettoStr) continue;

                // Parse amount
                let amount = 0;
                const cleanAmount = valNettoStr.replace(',', '.');
                amount = parseFloat(cleanAmount) || 0;

                // Parse date
                let parsedDate = null;
                let periodo = 'SCONOSCIUTO';

                if (dataStr) {
                    // Try different date formats: DD/MM/YYYY, DD-MM-YYYY, YYYY-MM-DD
                    const dateParts = dataStr.match(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})|(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})/);

                    if (dateParts) {
                        if (dateParts[1]) {
                            // DD/MM/YYYY or DD-MM-YYYY format
                            const day = parseInt(dateParts[1]);
                            const month = parseInt(dateParts[2]);
                            const year = parseInt(dateParts[3]);
                            parsedDate = new Date(year, month - 1, day);
                        } else {
                            // YYYY/MM/DD or YYYY-MM-DD format
                            const year = parseInt(dateParts[4]);
                            const month = parseInt(dateParts[5]);
                            const day = parseInt(dateParts[6]);
                            parsedDate = new Date(year, month - 1, day);
                        }

                        // Generate period string (YYYY-MM)
                        if (parsedDate && !isNaN(parsedDate.getTime())) {
                            const year = parsedDate.getFullYear();
                            const month = String(parsedDate.getMonth() + 1).padStart(2, '0');
                            periodo = `${year}-${month}`;
                        }
                    }
                }

                if (amount > 0) {
                    rawData.push({
                        operatore: operatore,
                        amount: amount,
                        codDep: codDep,
                        data: dataStr,
                        parsedDate: parsedDate,
                        periodo: periodo
                    });
                    shops.add(codDep);
                    validRows++;
                }
            }

            debugOutput += `✅ Parsing completato: ${validRows} righe valide\n`;

            // Analyze detected periods
            const periodsFound = new Set();
            rawData.forEach(record => {
                if (record.periodo !== 'SCONOSCIUTO') {
                    periodsFound.add(record.periodo);
                }
            });

            if (periodsFound.size > 0) {
                debugOutput += `\n📅 Periodi rilevati: ${periodsFound.size}\n`;
                const sortedPeriods = Array.from(periodsFound).sort();
                sortedPeriods.forEach(periodo => {
                    const recordsInPeriod = rawData.filter(r => r.periodo === periodo).length;
                    debugOutput += `  • ${periodo}: ${recordsInPeriod} transazioni\n`;
                });

                if (periodsFound.size > 1) {
                    debugOutput += `\n✨ Multi-periodo rilevato! Puoi ora filtrare per periodo specifico.\n`;
                }
            } else {
                debugOutput += `\n⚠️ Nessuna data valida rilevata. Verifica formato colonna DATA.\n`;
            }

            debug.textContent = debugOutput;

            if (rawData.length > 0) {
                // Calculate operator totals for rates table
                calculateOperatorTotals();

                // Populate shop filter
                const shopFilter = document.getElementById('shopFilter');
                shopFilter.innerHTML = '<option value="">Tutti i negozi</option>';
                Array.from(shops).sort().forEach(shop => {
                    const displayName = getShopDisplayName(shop);
                    shopFilter.innerHTML += `<option value="${shop}">${displayName}</option>`;
                });

                // Populate employee shop filter
                const employeeShopFilter = document.getElementById('employeeShopFilter');
                employeeShopFilter.innerHTML = '<option value="">Tutti i negozi</option>';
                Array.from(shops).sort().forEach(shop => {
                    const displayName = getShopDisplayName(shop);
                    employeeShopFilter.innerHTML += `<option value="${shop}">${displayName}</option>`;
                });

                // Populate period filter
                const periodsFound = new Set();
                rawData.forEach(record => {
                    if (record.periodo !== 'SCONOSCIUTO') {
                        periodsFound.add(record.periodo);
                    }
                });

                const periodFilter = document.getElementById('periodFilter');
                periodFilter.innerHTML = '<option value="">Tutti i periodi</option>';
                const sortedPeriods = Array.from(periodsFound).sort();
                sortedPeriods.forEach(periodo => {
                    const recordsCount = rawData.filter(r => r.periodo === periodo).length;
                    const [year, month] = periodo.split('-');
                    const monthNames = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu',
                                      'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'];
                    const monthName = monthNames[parseInt(month) - 1] || month;
                    periodFilter.innerHTML += `<option value="${periodo}">${monthName} ${year} (${recordsCount} trans.)</option>`;
                });

                // Build shops table with loaded data
                buildShopsTable();

                // Show controls and rates table
                document.getElementById('controls').classList.remove('hidden');
                buildRatesTable();

                // Auto-calculate dynamic seasonality factors
                calculateDynamicSeasonality(rawData);
                updateSeasonalityStatus();

                // Auto-switch to shops tab first
                showTab('shops');
                document.querySelector('.tab:nth-child(2)').classList.add('active');
                document.querySelector('.tab:nth-child(1)').classList.remove('active');
            }
        }

        function calculateOperatorTotals() {
            operatorTotals = {};

            rawData.forEach(record => {
                if (!operatorTotals[record.operatore]) {
                    operatorTotals[record.operatore] = {
                        operatore: record.operatore,
                        codDep: record.codDep,
                        totalSales: 0,
                        transactions: 0
                    };
                }
                operatorTotals[record.operatore].totalSales += record.amount;
                operatorTotals[record.operatore].transactions += 1;
            });
        }

        function buildRatesTable() {
            const container = document.getElementById('ratesTableContainer');
            const tbody = document.getElementById('ratesTableBody');
            const noDataMessage = document.getElementById('noDataMessage');

            if (Object.keys(operatorTotals).length === 0) {
                container.classList.add('hidden');
                noDataMessage.classList.remove('hidden');
                return;
            }

            container.classList.remove('hidden');
            noDataMessage.classList.add('hidden');

            const defaultRate = parseFloat(document.getElementById('defaultRate').value) / 100;

            // Sort operators by total sales
            const sortedOperators = Object.values(operatorTotals).sort((a, b) => b.totalSales - a.totalSales);

            tbody.innerHTML = '';

            sortedOperators.forEach(operator => {
                const customRate = customRates[operator.operatore] || defaultRate;
                const defaultCommission = operator.totalSales * defaultRate;
                const customCommission = operator.totalSales * customRate;
                const difference = customCommission - defaultCommission;

                const row = document.createElement('tr');
                if (customRates[operator.operatore]) {
                    row.classList.add('custom-rate');
                }

                const shopDisplayName = getShopDisplayName(operator.codDep);
                row.innerHTML = `
                    <td><strong>${operator.operatore}</strong></td>
                    <td>${shopDisplayName}</td>
                    <td class="currency">€${operator.totalSales.toLocaleString('it-IT', {minimumFractionDigits: 2})}</td>
                    <td class="text-center">
                        <input type="number" value="${(customRate * 100).toFixed(2)}"
                               step="0.01" min="0" max="100"
                               onchange="updateCustomRate('${operator.operatore}', this.value)"
                               style="width: 70px;" />%
                    </td>
                    <td class="currency">€${defaultCommission.toLocaleString('it-IT', {minimumFractionDigits: 2})}</td>
                    <td class="currency">€${customCommission.toLocaleString('it-IT', {minimumFractionDigits: 2})}</td>
                    <td class="currency" style="color: ${difference >= 0 ? '#28a745' : '#dc3545'};">
                        ${difference >= 0 ? '+' : ''}€${difference.toLocaleString('it-IT', {minimumFractionDigits: 2})}
                    </td>
                `;

                tbody.appendChild(row);
            });
        }

        function updateCustomRate(operatore, newRate) {
            const rate = parseFloat(newRate) / 100;
            if (rate >= 0) {
                customRates[operatore] = rate;
                buildRatesTable(); // Rebuild to update calculations
            }
        }

        function applyDefaultToAll() {
            if (confirm('Applicare la percentuale default a tutti gli operatori?')) {
                customRates = {};
                buildRatesTable();
            }
        }

        function resetCustomRates() {
            if (confirm('Cancellare tutte le percentuali personalizzate?')) {
                customRates = {};
                localStorage.removeItem('customCommissionRates');
                buildRatesTable();
            }
        }

        function processData() {
            if (rawData.length === 0) return;

            const calculationMode = document.getElementById('calculationMode').value;
            const analysisMode = document.getElementById('analysisMode').value;
            const defaultRate = parseFloat(document.getElementById('defaultRate').value) / 100;
            const shopFilter = document.getElementById('shopFilter').value;

            if (analysisMode === 'compare') {
                processComparisonData();
                return;
            } else if (analysisMode === 'timeline') {
                processTimelineData();
                return;
            }

            // Single period mode (existing logic)
            const periodFilter = document.getElementById('periodFilter').value;

            // Filter data if needed
            let filteredData = rawData;
            let filterInfo = '';

            if (shopFilter) {
                filteredData = filteredData.filter(r => r.codDep === shopFilter);
                const shopName = getShopDisplayName(shopFilter);
                filterInfo += `Negozio: ${shopName} • `;
            }

            if (periodFilter) {
                filteredData = filteredData.filter(r => r.periodo === periodFilter);
                const [year, month] = periodFilter.split('-');
                const monthNames = ['Gennaio', 'Febbraio', 'Marzo', 'Aprile', 'Maggio', 'Giugno',
                                  'Luglio', 'Agosto', 'Settembre', 'Ottobre', 'Novembre', 'Dicembre'];
                const monthName = monthNames[parseInt(month) - 1] || month;
                filterInfo += `Periodo: ${monthName} ${year} • `;
            }

            // Store filter info for display
            window.currentFilterInfo = filterInfo;

            // Group by shop and operator
            const shopOperatorGroups = {};
            const shopTotals = {};

            filteredData.forEach(record => {
                const shopKey = record.codDep;
                const operatorKey = `${record.codDep}|${record.operatore}`;

                // Shop totals
                if (!shopTotals[shopKey]) {
                    shopTotals[shopKey] = {
                        shop: shopKey,
                        totalSales: 0,
                        operators: new Set(),
                        transactions: 0
                    };
                }
                shopTotals[shopKey].totalSales += record.amount;
                shopTotals[shopKey].operators.add(record.operatore);
                shopTotals[shopKey].transactions += 1;

                // Shop-Operator combinations
                if (!shopOperatorGroups[operatorKey]) {
                    shopOperatorGroups[operatorKey] = {
                        shop: record.codDep,
                        operatore: record.operatore,
                        totalSales: 0,
                        transactions: 0
                    };
                }
                shopOperatorGroups[operatorKey].totalSales += record.amount;
                shopOperatorGroups[operatorKey].transactions += 1;
            });

            // Process pivot data with custom rates
            pivotData = [];
            Object.values(shopTotals).forEach(shop => {
                shop.operatorCount = shop.operators.size;

                // Get operators for this shop
                const shopOperators = Object.values(shopOperatorGroups)
                    .filter(item => item.shop === shop.shop)
                    .map(op => {
                        // Use custom rate if available, otherwise default
                        const rate = calculationMode === 'custom' && customRates[op.operatore] ?
                                   customRates[op.operatore] : defaultRate;

                        return {
                            ...op,
                            rate: rate,
                            commission: op.totalSales * rate,
                            percentageInShop: (op.totalSales / shop.totalSales) * 100,
                            isCustomRate: calculationMode === 'custom' && customRates[op.operatore] !== undefined
                        };
                    })
                    .sort((a, b) => b.commission - a.commission);

                // Calculate shop totals
                shop.commission = shopOperators.reduce((sum, op) => sum + op.commission, 0);
                shop.avgPerOperator = shop.operatorCount > 0 ? shop.commission / shop.operatorCount : 0;
                shop.operators = shopOperators;
                pivotData.push(shop);
            });

            // Sort shops by commission
            pivotData.sort((a, b) => b.commission - a.commission);

            renderResults();
        }

        // Process comparison between two periods
        function processComparisonData() {
            const calculationMode = document.getElementById('calculationMode').value;
            const defaultRate = parseFloat(document.getElementById('defaultRate').value) / 100;
            const shopFilter = document.getElementById('shopFilter').value;
            const periodA = document.getElementById('periodFilterA').value;
            const periodB = document.getElementById('periodFilterB').value;

            if (!periodA || !periodB) {
                alert('⚠️ Seleziona entrambi i periodi per il confronto!');
                return;
            }

            if (periodA === periodB) {
                alert('⚠️ Seleziona due periodi diversi per il confronto!');
                return;
            }

            // Filter data for both periods
            let dataA = rawData.filter(r => r.periodo === periodA);
            let dataB = rawData.filter(r => r.periodo === periodB);

            if (shopFilter) {
                dataA = dataA.filter(r => r.codDep === shopFilter);
                dataB = dataB.filter(r => r.codDep === shopFilter);
            }

            // Process both periods separately
            const resultA = processDataForPeriod(dataA, calculationMode, defaultRate, 'A');
            const resultB = processDataForPeriod(dataB, calculationMode, defaultRate, 'B');

            // Create comparison data structure
            pivotData = createComparisonData(resultA, resultB, periodA, periodB);

            // Set filter info for comparison
            const [yearA, monthA] = periodA.split('-');
            const [yearB, monthB] = periodB.split('-');
            const monthNames = ['Gennaio', 'Febbraio', 'Marzo', 'Aprile', 'Maggio', 'Giugno',
                              'Luglio', 'Agosto', 'Settembre', 'Ottobre', 'Novembre', 'Dicembre'];
            const monthNameA = monthNames[parseInt(monthA) - 1];
            const monthNameB = monthNames[parseInt(monthB) - 1];

            let filterInfo = `Confronto: ${monthNameA} ${yearA} vs ${monthNameB} ${yearB} • `;
            if (shopFilter) {
                const shopName = getShopDisplayName(shopFilter);
                filterInfo += `Negozio: ${shopName} • `;
            }

            window.currentFilterInfo = filterInfo;
            window.isComparisonMode = true;
            window.periodA = periodA;
            window.periodB = periodB;

            renderResults();
        }

        // Helper function to process data for a single period
        function processDataForPeriod(data, calculationMode, defaultRate, periodLabel) {
            const shopOperatorGroups = {};
            const shopTotals = {};

            data.forEach(record => {
                const shopKey = record.codDep;
                const operatorKey = `${record.codDep}|${record.operatore}`;

                // Shop totals
                if (!shopTotals[shopKey]) {
                    shopTotals[shopKey] = {
                        shop: shopKey,
                        totalSales: 0,
                        operators: new Set(),
                        transactions: 0
                    };
                }
                shopTotals[shopKey].totalSales += record.amount;
                shopTotals[shopKey].operators.add(record.operatore);
                shopTotals[shopKey].transactions += 1;

                // Shop-Operator combinations
                if (!shopOperatorGroups[operatorKey]) {
                    shopOperatorGroups[operatorKey] = {
                        shop: record.codDep,
                        operatore: record.operatore,
                        totalSales: 0,
                        transactions: 0
                    };
                }
                shopOperatorGroups[operatorKey].totalSales += record.amount;
                shopOperatorGroups[operatorKey].transactions += 1;
            });

            // Process pivot data
            const pivotResult = [];
            Object.values(shopTotals).forEach(shop => {
                shop.operatorCount = shop.operators.size;

                const shopOperators = Object.values(shopOperatorGroups)
                    .filter(item => item.shop === shop.shop)
                    .map(op => {
                        const rate = calculationMode === 'custom' && customRates[op.operatore] ?
                                   customRates[op.operatore] : defaultRate;

                        return {
                            ...op,
                            rate: rate,
                            commission: op.totalSales * rate,
                            percentageInShop: (op.totalSales / shop.totalSales) * 100,
                            isCustomRate: calculationMode === 'custom' && customRates[op.operatore] !== undefined
                        };
                    })
                    .sort((a, b) => b.commission - a.commission);

                shop.commission = shopOperators.reduce((sum, op) => sum + op.commission, 0);
                shop.avgPerOperator = shop.operatorCount > 0 ? shop.commission / shop.operatorCount : 0;
                shop.operators = shopOperators;
                pivotResult.push(shop);
            });

            return pivotResult.sort((a, b) => b.commission - a.commission);
        }

        // Create comparison data structure with growth calculations
        function createComparisonData(resultA, resultB, periodA, periodB) {
            const comparisonData = [];

            // Get all shops from both periods
            const allShops = new Set();
            resultA.forEach(shop => allShops.add(shop.shop));
            resultB.forEach(shop => allShops.add(shop.shop));

            Array.from(allShops).forEach(shopCode => {
                const shopA = resultA.find(s => s.shop === shopCode);
                const shopB = resultB.find(s => s.shop === shopCode);

                const salesA = shopA ? shopA.totalSales : 0;
                const salesB = shopB ? shopB.totalSales : 0;
                const commissionA = shopA ? shopA.commission : 0;
                const commissionB = shopB ? shopB.commission : 0;

                // Calculate growth percentages
                const salesGrowth = salesA > 0 ? ((salesB - salesA) / salesA) * 100 : (salesB > 0 ? 100 : 0);
                const commissionGrowth = commissionA > 0 ? ((commissionB - commissionA) / commissionA) * 100 : (commissionB > 0 ? 100 : 0);

                comparisonData.push({
                    shop: shopCode,
                    periodA: periodA,
                    periodB: periodB,
                    salesA: salesA,
                    salesB: salesB,
                    commissionA: commissionA,
                    commissionB: commissionB,
                    salesGrowth: salesGrowth,
                    commissionGrowth: commissionGrowth,
                    operatorCountA: shopA ? shopA.operatorCount : 0,
                    operatorCountB: shopB ? shopB.operatorCount : 0,
                    transactionsA: shopA ? shopA.transactions : 0,
                    transactionsB: shopB ? shopB.transactions : 0,
                    // Keep detailed operator data for expanded view
                    operatorsA: shopA ? shopA.operators : [],
                    operatorsB: shopB ? shopB.operators : []
                });
            });

            return comparisonData.sort((a, b) => Math.abs(b.salesGrowth) - Math.abs(a.salesGrowth));
        }

        // Process timeline evolution data
        function processTimelineData() {
            console.log('🔄 Starting processTimelineData');
            const calculationMode = document.getElementById('calculationMode').value;
            const defaultRate = parseFloat(document.getElementById('defaultRate').value) / 100;
            const shopFilter = document.getElementById('shopFilter').value;
            console.log('📋 Timeline params:', { calculationMode, defaultRate, shopFilter });

            // Get all periods and sort them
            const periodsFound = new Set();
            rawData.forEach(record => {
                if (record.periodo !== 'SCONOSCIUTO') {
                    periodsFound.add(record.periodo);
                }
            });
            console.log('📅 Periods found:', Array.from(periodsFound));

            if (periodsFound.size < 2) {
                alert('⚠️ Servono almeno 2 periodi per la vista Timeline!');
                return;
            }

            const sortedPeriods = Array.from(periodsFound).sort();

            // Process data for each period
            const timelineData = {};

            sortedPeriods.forEach(periodo => {
                let periodData = rawData.filter(r => r.periodo === periodo);

                if (shopFilter) {
                    periodData = periodData.filter(r => r.codDep === shopFilter);
                }

                const result = processDataForPeriod(periodData, calculationMode, defaultRate, periodo);
                timelineData[periodo] = result;
            });

            // Create timeline visualization data
            pivotData = createTimelineVisualizationData(timelineData, sortedPeriods);

            // PHASE 5: Generate predictions for each shop
            pivotData.forEach(shop => {
                const prediction = predictNextPeriod(shop);
                const seasonalAnalysis = analyzeSeasonalTrends(shop);
                shop.prediction = prediction;
                shop.seasonal = seasonalAnalysis;
            });

            // Generate prediction alerts
            const alerts = generatePredictionAlerts(pivotData.map(shop => ({
                shop: shop.shop,
                ...shop.prediction
            })));
            window.predictionAlerts = alerts;

            // Set filter info for timeline
            let filterInfo = `Timeline Evolution (${sortedPeriods.length} periodi) • `;
            if (shopFilter) {
                const shopName = getShopDisplayName(shopFilter);
                filterInfo += `Negozio: ${shopName} • `;
            }

            window.currentFilterInfo = filterInfo;
            window.isTimelineMode = true;
            window.timelinePeriods = sortedPeriods;

            renderResults();
        }

        // Create timeline visualization data structure
        function createTimelineVisualizationData(timelineData, periods) {
            const timelineVisualization = [];

            // Get all unique shops from all periods
            const allShops = new Set();
            Object.values(timelineData).forEach(periodData => {
                periodData.forEach(shop => allShops.add(shop.shop));
            });

            Array.from(allShops).forEach(shopCode => {
                const shopTimeline = {
                    shop: shopCode,
                    periods: periods,
                    data: {}
                };

                periods.forEach(periodo => {
                    const periodData = timelineData[periodo] || [];
                    const shopInPeriod = periodData.find(s => s.shop === shopCode);

                    shopTimeline.data[periodo] = {
                        sales: shopInPeriod ? shopInPeriod.totalSales : 0,
                        commission: shopInPeriod ? shopInPeriod.commission : 0,
                        operators: shopInPeriod ? shopInPeriod.operatorCount : 0,
                        transactions: shopInPeriod ? shopInPeriod.transactions : 0,
                        topOperators: shopInPeriod ? shopInPeriod.operators.slice(0, 3) : []
                    };
                });

                // Calculate trends
                const salesValues = periods.map(p => shopTimeline.data[p].sales);
                const avgGrowth = calculateAverageGrowth(salesValues);
                const yoyGrowth = calculateShopYearOverYearGrowth(shopTimeline.data, periods);
                shopTimeline.avgGrowth = avgGrowth;
                shopTimeline.yoyGrowth = yoyGrowth;
                shopTimeline.totalSales = salesValues.reduce((sum, val) => sum + val, 0);

                timelineVisualization.push(shopTimeline);
            });

            return timelineVisualization.sort((a, b) => b.totalSales - a.totalSales);
        }

        // Helper function to calculate average growth
        function calculateAverageGrowth(values) {
            if (values.length < 2) return 0;

            const growthRates = [];
            for (let i = 1; i < values.length; i++) {
                if (values[i - 1] > 0) {
                    const growth = ((values[i] - values[i - 1]) / values[i - 1]) * 100;
                    growthRates.push(growth);
                }
            }

            const avgGrowth = growthRates.length > 0 ? growthRates.reduce((sum, rate) => sum + rate, 0) / growthRates.length : 0;

            // Debug logging for Valmontone to understand the discrepancy
            if (values.length === 32 && Math.abs(avgGrowth - 1.7) < 0.1) {
                console.log(`🔍 VALMONTONE GROWTH DEBUG:`);
                console.log(`   Total periods analyzed: ${values.length}`);
                console.log(`   Sales values (first 5):`, values.slice(0, 5).map(v => `€${v.toFixed(0)}`));
                console.log(`   Sales values (last 5):`, values.slice(-5).map(v => `€${v.toFixed(0)}`));
                console.log(`   Month-to-month growth rates:`, growthRates.slice(0, 10).map(r => `${r.toFixed(1)}%`));
                console.log(`   Average growth (all periods): ${avgGrowth.toFixed(1)}%`);

                // Calculate year-over-year for September specifically
                const sept2023 = values[8]; // September 2023 (index 8)
                const sept2024 = values[20]; // September 2024 (index 20)
                if (sept2023 && sept2024) {
                    const septYoY = ((sept2024 - sept2023) / sept2023) * 100;
                    console.log(`   September 2023: €${sept2023.toFixed(0)}`);
                    console.log(`   September 2024: €${sept2024.toFixed(0)}`);
                    console.log(`   September YoY growth: ${septYoY.toFixed(1)}%`);
                    console.log(`   ❗ DISCREPANCY: Card shows ${avgGrowth.toFixed(1)}% (all periods) vs Console shows ${septYoY.toFixed(1)}% (Sept only)`);
                }
            }

            return avgGrowth;
        }

        // Helper function to calculate year-over-year growth for individual shops
        function calculateShopYearOverYearGrowth(shopData, periods) {
            if (!shopData || periods.length < 2) return 0;

            // Get the latest period
            const latestPeriod = periods[periods.length - 1];
            const [currentYear, currentMonth] = latestPeriod.split('-');
            const lastYear = String(parseInt(currentYear) - 1);
            const sameMonthLastYear = `${lastYear}-${currentMonth}`;

            // Check if we have data for both current and last year same month
            const currentData = shopData[latestPeriod];
            const lastYearData = shopData[sameMonthLastYear];

            if (!currentData || !lastYearData || lastYearData.sales <= 0) {
                // If no same-month comparison available, calculate average YoY across available periods
                const yoyComparisons = [];

                periods.forEach(period => {
                    const [year, month] = period.split('-');
                    const previousYearPeriod = `${parseInt(year) - 1}-${month}`;

                    if (shopData[period] && shopData[previousYearPeriod] && shopData[previousYearPeriod].sales > 0) {
                        const yoy = ((shopData[period].sales - shopData[previousYearPeriod].sales) / shopData[previousYearPeriod].sales) * 100;
                        yoyComparisons.push(yoy);
                    }
                });

                return yoyComparisons.length > 0 ?
                    yoyComparisons.reduce((sum, growth) => sum + growth, 0) / yoyComparisons.length : 0;
            }

            // Calculate YoY for same month
            return ((currentData.sales - lastYearData.sales) / lastYearData.sales) * 100;
        }

        // Calculate SIMPLE and USEFUL metrics (replacing complex overengineered stuff)
        function calculateSimpleUsefulMetrics(pivotData, periods) {
            const metrics = {
                currentMonth: '',
                lastYearSameMonth: '',
                thisYearTotal: 0,
                lastYearTotal: 0,
                yoyGrowth: 0,
                problemShops: [],
                topGrowingShop: null,
                topDecliningShop: null,
                seasonalBenchmark: null
            };

            // Get current month info
            const latestPeriod = periods[periods.length - 1];
            const [currentYear, currentMonth] = latestPeriod.split('-');
            const lastYear = String(parseInt(currentYear) - 1);
            const sameMonthLastYear = `${lastYear}-${currentMonth}`;

            metrics.currentMonth = latestPeriod;
            metrics.lastYearSameMonth = sameMonthLastYear;

            console.log(`📊 SIMPLE METRICS: Comparing ${latestPeriod} vs ${sameMonthLastYear}`);

            // Calculate COMPREHENSIVE year-over-year (all months comparison)
            const monthlyComparisons = [];
            const availableMonths = [];

            // Get all months where we have both this year and last year data
            periods.forEach(period => {
                const [year, month] = period.split('-');
                const lastYearPeriod = `${parseInt(year) - 1}-${month}`;

                if (periods.includes(lastYearPeriod)) {
                    availableMonths.push({ current: period, lastYear: lastYearPeriod, month: month });
                }
            });

            console.log(`📊 Found ${availableMonths.length} months for YoY comparison:`, availableMonths.map(m => `${m.current} vs ${m.lastYear}`));

            // Calculate YoY for each month and average them
            availableMonths.forEach(monthPair => {
                let thisYearMonthSales = 0;
                let lastYearMonthSales = 0;

                pivotData.forEach(shop => {
                    const currentData = shop.data[monthPair.current];
                    const lastYearData = shop.data[monthPair.lastYear];

                    if (currentData) thisYearMonthSales += currentData.sales;
                    if (lastYearData) lastYearMonthSales += lastYearData.sales;
                });

                if (lastYearMonthSales > 0) {
                    const monthlyYoY = ((thisYearMonthSales - lastYearMonthSales) / lastYearMonthSales) * 100;
                    monthlyComparisons.push({
                        month: monthPair.month,
                        currentPeriod: monthPair.current,
                        lastYearPeriod: monthPair.lastYear,
                        thisYear: thisYearMonthSales,
                        lastYear: lastYearMonthSales,
                        yoyGrowth: monthlyYoY
                    });

                    console.log(`   ${monthPair.current}: €${thisYearMonthSales.toFixed(0)} vs ${monthPair.lastYear}: €${lastYearMonthSales.toFixed(0)} = ${monthlyYoY.toFixed(1)}%`);
                }
            });

            // Calculate average YoY growth across all months
            const avgYoYGrowth = monthlyComparisons.length > 0 ?
                monthlyComparisons.reduce((sum, comp) => sum + comp.yoyGrowth, 0) / monthlyComparisons.length : 0;

            // Also calculate totals for reference
            const thisYearTotal = monthlyComparisons.reduce((sum, comp) => sum + comp.thisYear, 0);
            const lastYearTotal = monthlyComparisons.reduce((sum, comp) => sum + comp.lastYear, 0);

            // Individual shop YoY analysis
            pivotData.forEach(shop => {
                const currentData = shop.data[latestPeriod];
                const lastYearData = shop.data[sameMonthLastYear];
                if (currentData && lastYearData && lastYearData.sales > 1000) {
                    const shopYoY = ((currentData.sales - lastYearData.sales) / lastYearData.sales) * 100;

                    // Flag real problems (not seasonal noise)
                    if (shopYoY < -40) {
                        metrics.problemShops.push({
                            shop: shop.shop,
                            yoyChange: shopYoY,
                            current: currentData.sales,
                            lastYear: lastYearData.sales
                        });
                    }

                    // Track best/worst performers
                    if (!metrics.topGrowingShop || shopYoY > metrics.topGrowingShop.yoyChange) {
                        metrics.topGrowingShop = {
                            shop: shop.shop,
                            yoyChange: shopYoY,
                            current: currentData.sales,
                            lastYear: lastYearData.sales
                        };
                    }

                    if (!metrics.topDecliningShop || shopYoY < metrics.topDecliningShop.yoyChange) {
                        metrics.topDecliningShop = {
                            shop: shop.shop,
                            yoyChange: shopYoY,
                            current: currentData.sales,
                            lastYear: lastYearData.sales
                        };
                    }
                }
            });

            metrics.thisYearTotal = thisYearTotal;
            metrics.lastYearTotal = lastYearTotal;
            metrics.yoyGrowth = avgYoYGrowth;
            metrics.monthlyComparisons = monthlyComparisons;
            metrics.availableComparisons = monthlyComparisons.length;

            // Create seasonal benchmark (simple median of past years for this month)
            const monthNumber = parseInt(currentMonth);
            const monthlyTotals = [];

            // Calculate current month total for benchmark comparison
            const thisYearSales = pivotData.reduce((sum, shop) =>
                sum + (shop.data[latestPeriod] ? shop.data[latestPeriod].sales : 0), 0);

            periods.forEach(period => {
                const [year, month] = period.split('-');
                if (parseInt(month) === monthNumber && year !== currentYear) {
                    const monthTotal = pivotData.reduce((sum, shop) =>
                        sum + (shop.data[period] ? shop.data[period].sales : 0), 0);
                    if (monthTotal > 0) monthlyTotals.push(monthTotal);
                }
            });

            if (monthlyTotals.length > 0) {
                monthlyTotals.sort((a, b) => a - b);
                const median = monthlyTotals[Math.floor(monthlyTotals.length / 2)];
                const min = monthlyTotals[0];
                const max = monthlyTotals[monthlyTotals.length - 1];

                metrics.seasonalBenchmark = {
                    median: median,
                    range: [min, max],
                    dataPoints: monthlyTotals.length,
                    status: thisYearSales > median * 1.1 ? 'above_normal' :
                           thisYearSales < median * 0.9 ? 'below_normal' : 'normal'
                };
            }

            console.log(`📈 COMPREHENSIVE YoY Growth: ${metrics.yoyGrowth.toFixed(1)}% (average of ${monthlyComparisons.length} monthly comparisons)`);
            console.log(`   Individual monthly growth rates:`, monthlyComparisons.map(c => `${c.month}: ${c.yoyGrowth.toFixed(1)}%`));
            console.log(`⚠️ Problem shops: ${metrics.problemShops.length}`);
            console.log(`🏆 Top grower: ${metrics.topGrowingShop?.shop} (${metrics.topGrowingShop?.yoyChange.toFixed(1)}%)`);

            return metrics;
        }

        // Calculate comprehensive growth metrics for enhanced stats (DEPRECATED - TO BE REMOVED)
        function calculateComprehensiveGrowthMetrics(pivotData, periods) {
            const metrics = {
                bestMonthlyGrowth: { shop: '', value: -Infinity, icon: '📉', color: '#dc3545' },
                bestYearOverYear: { shop: '', value: -Infinity, icon: '📉', color: '#dc3545' },
                avgTrendSlope: 0,
                totalShopsGrowing: 0,
                totalShopsDeclining: 0
            };

            let totalSlope = 0;
            let validShops = 0;

            pivotData.forEach(shop => {
                // Monthly growth (existing avgGrowth)
                if (shop.avgGrowth > metrics.bestMonthlyGrowth.value) {
                    metrics.bestMonthlyGrowth.value = shop.avgGrowth;
                    metrics.bestMonthlyGrowth.shop = shop.shop;
                    metrics.bestMonthlyGrowth.icon = shop.avgGrowth >= 0 ? '📈' : '📉';
                    metrics.bestMonthlyGrowth.color = shop.avgGrowth >= 0 ? '#28a745' : '#dc3545';
                }

                // Year-over-year growth (same month comparison)
                const currentYear = parseInt(periods[periods.length - 1].split('-')[0]);
                const currentMonth = parseInt(periods[periods.length - 1].split('-')[1]);

                // Find same month in current year and previous year
                const currentYearData = periods
                    .filter(p => p.startsWith(`${currentYear}-`))
                    .map(p => shop.data[p].sales)
                    .reduce((sum, val) => sum + val, 0);

                const previousYearData = periods
                    .filter(p => p.startsWith(`${currentYear - 1}-`))
                    .map(p => shop.data[p].sales)
                    .reduce((sum, val) => sum + val, 0);

                if (previousYearData > 0) {
                    const yoyGrowth = ((currentYearData - previousYearData) / previousYearData) * 100;

                    if (yoyGrowth > metrics.bestYearOverYear.value) {
                        metrics.bestYearOverYear.value = yoyGrowth;
                        metrics.bestYearOverYear.shop = shop.shop;
                        metrics.bestYearOverYear.icon = yoyGrowth >= 0 ? '📈' : '📉';
                        metrics.bestYearOverYear.color = yoyGrowth >= 0 ? '#28a745' : '#dc3545';
                    }
                }

                // Trend slope from prediction
                if (shop.prediction && shop.prediction.slope) {
                    totalSlope += shop.prediction.slope;
                    validShops++;
                }

                // Count growing vs declining shops
                if (shop.avgGrowth > 2) {
                    metrics.totalShopsGrowing++;
                } else if (shop.avgGrowth < -2) {
                    metrics.totalShopsDeclining++;
                }
            });

            metrics.avgTrendSlope = validShops > 0 ? totalSlope / validShops : 0;

            // Debug output
            console.log('📈 COMPREHENSIVE METRICS DEBUG:');
            console.log(`   Best monthly growth: ${metrics.bestMonthlyGrowth.shop} (${metrics.bestMonthlyGrowth.value.toFixed(1)}%)`);
            console.log(`   Best year-over-year: ${metrics.bestYearOverYear.shop} (${metrics.bestYearOverYear.value.toFixed(1)}%)`);
            console.log(`   Shops growing: ${metrics.totalShopsGrowing}`);
            console.log(`   Shops declining: ${metrics.totalShopsDeclining}`);

            return metrics;
        }

        // Calculate month-over-month trends across multiple years
        function calculateMonthOverMonthTrends(pivotData, periods) {
            const monthTrends = {};
            const monthNames = ['', 'Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'];

            console.log('📅 CALCULATING MONTH-OVER-MONTH TRENDS ACROSS YEARS...');

            for (let month = 1; month <= 12; month++) {
                const monthData = [];

                // Collect data for this month across all years
                periods.forEach(period => {
                    const [year, monthStr] = period.split('-');
                    if (parseInt(monthStr) === month) {
                        const yearNum = parseInt(year);

                        // Sum total sales for all shops in this month/year
                        const totalSales = pivotData.reduce((sum, shop) =>
                            sum + (shop.data[period] ? shop.data[period].sales : 0), 0);

                        if (totalSales > 0) {
                            monthData.push({ year: yearNum, sales: totalSales, period: period });
                        }
                    }
                });

                // Sort by year
                monthData.sort((a, b) => a.year - b.year);

                if (monthData.length >= 2) {
                    // Calculate year-over-year growth rates for this month
                    const growthRates = [];
                    for (let i = 1; i < monthData.length; i++) {
                        const currentYear = monthData[i];
                        const previousYear = monthData[i - 1];

                        if (previousYear.sales > 0) {
                            const growthRate = ((currentYear.sales - previousYear.sales) / previousYear.sales) * 100;
                            growthRates.push({
                                fromYear: previousYear.year,
                                toYear: currentYear.year,
                                growth: growthRate,
                                fromSales: previousYear.sales,
                                toSales: currentYear.sales
                            });
                        }
                    }

                    // Calculate average trend for this month
                    const avgGrowth = growthRates.length > 0 ?
                        growthRates.reduce((sum, rate) => sum + rate.growth, 0) / growthRates.length : 0;

                    monthTrends[month] = {
                        monthName: monthNames[month],
                        monthNumber: month,
                        yearData: monthData,
                        growthRates: growthRates,
                        avgTrend: avgGrowth,
                        consistency: calculateTrendConsistency(growthRates),
                        direction: avgGrowth > 1 ? 'growing' : avgGrowth < -1 ? 'declining' : 'stable',
                        icon: avgGrowth > 1 ? '📈' : avgGrowth < -1 ? '📉' : '➡️',
                        color: avgGrowth > 1 ? '#28a745' : avgGrowth < -1 ? '#dc3545' : '#6c757d'
                    };

                    // Debug logging for September (month 9) specifically
                    if (month === 9) {
                        console.log(`📊 SETTEMBRE TREND ANALYSIS:`);
                        console.log(`   Years available:`, monthData.map(d => `${d.year}: €${d.sales.toFixed(0)}`));
                        console.log(`   Growth rates:`, growthRates.map(g => `${g.fromYear}→${g.toYear}: ${g.growth.toFixed(1)}%`));
                        console.log(`   Average trend: ${avgGrowth.toFixed(1)}%`);
                        console.log(`   Direction: ${monthTrends[month].direction}`);
                    }
                }
            }

            // Show summary of all month trends
            console.log('📊 SUMMARY OF MONTHLY TRENDS ACROSS YEARS:');
            for (let month = 1; month <= 12; month++) {
                if (monthTrends[month]) {
                    const trend = monthTrends[month];
                    console.log(`   ${trend.monthName}: ${trend.icon} ${trend.avgTrend > 0 ? '+' : ''}${trend.avgTrend.toFixed(1)}% (${trend.consistency})`);
                }
            }

            return monthTrends;
        }

        // Helper function to calculate trend consistency
        function calculateTrendConsistency(growthRates) {
            if (growthRates.length < 2) return 'insufficient_data';

            const positiveGrowth = growthRates.filter(rate => rate.growth > 0).length;
            const negativeGrowth = growthRates.filter(rate => rate.growth < 0).length;
            const total = growthRates.length;

            if (positiveGrowth === total) return 'consistently_growing';
            if (negativeGrowth === total) return 'consistently_declining';
            if (Math.abs(positiveGrowth - negativeGrowth) <= 1) return 'mixed';
            if (positiveGrowth > negativeGrowth) return 'mostly_growing';
            return 'mostly_declining';
        }

        // ===== PHASE 5: TREND PREDICTION ALGORITHMS =====

        // Linear regression prediction for next period
        function predictNextPeriod(shop) {
            const periods = window.timelinePeriods;
            if (!periods || periods.length < 3) return { prediction: 0, confidence: 'low', trend: 'insufficient_data' };

            const salesValues = periods.map(p => shop.data[p].sales);

            console.log(`🔄 Predicting for shop: ${shop.shop}`);
            console.log(`📅 Periods available:`, periods);
            console.log(`💰 Sales values:`, salesValues);

            // Try Fashion Seasonal Model first
            const seasonalPrediction = predictFashionSeasonal(shop, periods, salesValues);
            console.log(`🌟 Seasonal prediction result:`, seasonalPrediction);

            if (seasonalPrediction.confidence !== 'insufficient_data') {
                console.log(`✅ Using SEASONAL model for ${shop.shop}`);
                return seasonalPrediction;
            }

            // Fallback to Linear Model
            console.log(`⚠️ Falling back to LINEAR model for ${shop.shop}`);
            const linearResult = predictLinear(salesValues, periods);
            console.log(`📊 Linear prediction result:`, linearResult);
            return linearResult;
        }

        // Fashion-Specific Seasonal Prediction Model
        function predictFashionSeasonal(shop, periods, salesValues) {
            try {
                // Calculate temporal distances between periods (months)
                function calculateMonthsDifference(period1, period2) {
                    const [year1, month1] = period1.split('-').map(Number);
                    const [year2, month2] = period2.split('-').map(Number);
                    return (year2 - year1) * 12 + (month2 - month1);
                }

                // Extract month information with real temporal distances
                const basePeriod = periods[0];
                const monthData = periods.map((period, index) => ({
                    period: period,
                    month: parseInt(period.split('-')[1]), // Extract month (1-12)
                    year: parseInt(period.split('-')[0]),   // Extract year
                    sales: salesValues[index],
                    monthsFromStart: calculateMonthsDifference(basePeriod, period) // Real temporal distance
                })).filter(d => d.sales > 0);

                // Require minimum 6 data points for reliable seasonal predictions
                if (monthData.length < 6) return { prediction: 0, confidence: 'insufficient_data', trend: 'insufficient_data' };

                // Get seasonality factors based on user selection
                const selectedMode = document.querySelector('input[name="seasonalityMode"]:checked')?.value || 'fixed';
                let fashionSeasonality;

                if (selectedMode === 'dynamic' && dynamicSeasonalityFactors) {
                    fashionSeasonality = dynamicSeasonalityFactors;
                    console.log(`🎯 Using DYNAMIC seasonality for ${shop.shop}:`, fashionSeasonality);
                } else {
                    // Realistic Fashion Seasonal Factors (max 1.10 variation)
                    fashionSeasonality = {
                        1: 0.90,  // Gennaio - Post-Natale, saldi invernali
                        2: 0.92,  // Febbraio - Fine inverno
                        3: 1.05,  // Marzo - Nuove collezioni primavera
                        4: 1.02,  // Aprile - Primavera
                        5: 0.95,  // Maggio - Pre-estate
                        6: 0.93,  // Giugno - Inizio estate
                        7: 0.90,  // Luglio - Saldi estivi
                        8: 0.88,  // Agosto - Vacanze
                        9: 1.10,  // Settembre - Rientro, nuove collezioni autunno
                        10: 1.08, // Ottobre - Autunno pieno
                        11: 1.05, // Novembre - Pre-natalizio
                        12: 1.10  // Dicembre - Natale (picco moderato)
                    };
                    console.log(`📊 Using FIXED seasonality for ${shop.shop}`);
                }

                // Deseasonalize data to find base trend
                const deseasonalizedData = monthData.map(d => ({
                    ...d,
                    deseasonalized: d.sales / fashionSeasonality[d.month]
                }));

                // Linear regression using real temporal distances
                const n = deseasonalizedData.length;
                const sumX = deseasonalizedData.reduce((sum, d) => sum + d.monthsFromStart, 0);
                const sumY = deseasonalizedData.reduce((sum, d) => sum + d.deseasonalized, 0);
                const sumXY = deseasonalizedData.reduce((sum, d) => sum + (d.monthsFromStart * d.deseasonalized), 0);
                const sumX2 = deseasonalizedData.reduce((sum, d) => sum + (d.monthsFromStart * d.monthsFromStart), 0);

                const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                const intercept = (sumY - slope * sumX) / n;

                // Predict next period using real temporal distance
                const lastPeriod = periods[periods.length - 1];
                const nextPeriod = getNextPeriod(lastPeriod);
                const nextMonth = parseInt(nextPeriod.split('-')[1]);
                const nextMonthsFromStart = calculateMonthsDifference(basePeriod, nextPeriod);

                // Base prediction (deseasonalized)
                const basePrediction = slope * nextMonthsFromStart + intercept;

                // Apply seasonal factor
                const seasonalFactor = fashionSeasonality[nextMonth];
                const finalPrediction = basePrediction * seasonalFactor;

                // Improved year-over-year growth constraint considering multi-year trends
                const lastYearSameMonth = monthData.find(d =>
                    d.month === nextMonth && d.year === (parseInt(nextPeriod.split('-')[0]) - 1)
                );
                const twoYearsAgoSameMonth = monthData.find(d =>
                    d.month === nextMonth && d.year === (parseInt(nextPeriod.split('-')[0]) - 2)
                );

                let constrainedPrediction = finalPrediction;
                let yearOverYearGrowth1 = null; // Declare outside scope

                if (lastYearSameMonth) {
                    // Calculate multi-year trend if available
                    let growthRate = 0.15; // Default 15% max growth

                    if (twoYearsAgoSameMonth) {
                        // Calculate 2-year average growth rate
                        yearOverYearGrowth1 = (lastYearSameMonth.sales - twoYearsAgoSameMonth.sales) / twoYearsAgoSameMonth.sales;

                        // If there's a consistent declining trend, allow it to continue (but cap at -20%)
                        if (yearOverYearGrowth1 < 0) {
                            growthRate = Math.max(-0.20, yearOverYearGrowth1 * 1.5); // Allow 1.5x the historical decline rate
                        } else {
                            growthRate = Math.min(0.15, yearOverYearGrowth1 * 1.2); // Allow 1.2x the historical growth rate
                        }
                    }

                    const maxAllowedGrowth = lastYearSameMonth.sales * (1 + growthRate);
                    const minAllowedGrowth = lastYearSameMonth.sales * (1 - Math.abs(growthRate));
                    constrainedPrediction = Math.min(maxAllowedGrowth, Math.max(minAllowedGrowth, finalPrediction));

                    console.log(`📊 Improved YoY Constraint for ${shop.shop}:`);
                    console.log(`   Last year same month: €${lastYearSameMonth.sales.toFixed(0)}`);
                    if (twoYearsAgoSameMonth && yearOverYearGrowth1 !== null) {
                        console.log(`   Two years ago: €${twoYearsAgoSameMonth.sales.toFixed(0)}`);
                        console.log(`   Historical trend: ${(yearOverYearGrowth1 * 100).toFixed(1)}%`);
                        console.log(`   Dynamic growth rate: ${(growthRate * 100).toFixed(1)}%`);
                    }
                    console.log(`   Raw prediction: €${finalPrediction.toFixed(0)}`);
                    console.log(`   Constrained: €${constrainedPrediction.toFixed(0)}`);
                }

                // Debug logging for specific shops
                if (shop.shop.toUpperCase().includes('VALMONTONE')) {
                    console.log(`🔍 VALMONTONE DEBUG:`);
                    console.log(`   Available periods:`, monthData.map(d => `${d.period}: €${d.sales.toFixed(0)}`));
                    console.log(`   Slope (monthly growth): ${slope.toFixed(2)}`);
                    console.log(`   Base prediction (deseasonalized): €${basePrediction.toFixed(0)}`);
                    console.log(`   Seasonal factor (month ${nextMonth}): ${seasonalFactor.toFixed(3)}`);
                    console.log(`   Final prediction: €${finalPrediction.toFixed(0)}`);
                    console.log(`   YoY constraint: €${constrainedPrediction.toFixed(0)}`);
                }

                // REMOVED: Overly restrictive "recent average" constraint
                // This was causing predictions to be artificially low
                const smoothedPrediction = constrainedPrediction;

                // Calculate R² on original data vs seasonal model
                const seasonalPredicted = monthData.map((d) => {
                    const baseValue = slope * d.monthsFromStart + intercept;
                    return baseValue * fashionSeasonality[d.month];
                });

                const r2 = calculateR2(monthData.map(d => d.sales), seasonalPredicted);

                // Stricter confidence thresholds for realistic predictions
                let confidence = 'low';
                if (r2 > 0.7 && monthData.length >= 8) confidence = 'high';
                else if (r2 > 0.4 && monthData.length >= 6) confidence = 'medium';

                // Trend analysis with realistic thresholds
                const yearOverYearGrowth = calculateYearOverYearGrowth(monthData);
                let trend = 'stable';
                if (yearOverYearGrowth > 8) trend = 'growing';
                else if (yearOverYearGrowth < -8) trend = 'declining';

                return {
                    prediction: smoothedPrediction,
                    confidence: confidence,
                    trend: trend,
                    slope: slope,
                    r2: r2,
                    seasonalFactor: seasonalFactor,
                    basePrediction: basePrediction,
                    yearOverYearGrowth: yearOverYearGrowth,
                    modelType: 'seasonal-fashion-v2',
                    nextMonth: nextMonth,
                    regressionLine: { slope, intercept },
                    constrainedBy: lastYearSameMonth ? 'year-over-year-15pct' : 'recent-average',
                    dataPoints: monthData.length
                };

            } catch (error) {
                console.warn('Seasonal prediction failed:', error);
                return { prediction: 0, confidence: 'insufficient_data', trend: 'insufficient_data' };
            }
        }

        // Helper: Calculate year-over-year growth for seasonal trend
        function calculateYearOverYearGrowth(monthData) {
            const monthGroups = {};
            monthData.forEach(d => {
                if (!monthGroups[d.month]) monthGroups[d.month] = [];
                monthGroups[d.month].push(d);
            });

            let totalGrowth = 0;
            let comparisons = 0;

            Object.values(monthGroups).forEach(months => {
                if (months.length >= 2) {
                    months.sort((a, b) => a.year - b.year);
                    for (let i = 1; i < months.length; i++) {
                        const growth = ((months[i].sales - months[i-1].sales) / months[i-1].sales) * 100;
                        totalGrowth += growth;
                        comparisons++;
                    }
                }
            });

            return comparisons > 0 ? totalGrowth / comparisons : 0;
        }

        // Helper: Get next period string
        function getNextPeriod(currentPeriod) {
            const [year, month] = currentPeriod.split('-');
            let nextMonth = parseInt(month) + 1;
            let nextYear = parseInt(year);

            if (nextMonth > 12) {
                nextMonth = 1;
                nextYear += 1;
            }

            return `${nextYear}-${nextMonth.toString().padStart(2, '0')}`;
        }

        // Fallback Linear Regression (Original improved)
        function predictLinear(salesValues, periods) {
            const validValues = [];
            const validIndices = [];
            salesValues.forEach((value, index) => {
                if (value > 0) {
                    validValues.push(value);
                    validIndices.push(index);
                }
            });

            if (validValues.length < 3) return { prediction: 0, confidence: 'low', trend: 'insufficient_data' };

            const n = validValues.length;
            const sumX = validIndices.reduce((sum, val) => sum + val, 0);
            const sumY = validValues.reduce((sum, val) => sum + val, 0);
            const sumXY = validValues.reduce((sum, val, i) => sum + validIndices[i] * val, 0);
            const sumX2 = validIndices.reduce((sum, val) => sum + val * val, 0);

            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;

            const nextIndex = periods.length;
            const nextPrediction = slope * nextIndex + intercept;

            const predicted = validIndices.map(x => slope * x + intercept);
            const r2 = calculateR2(validValues, predicted);

            let confidence = 'low';
            if (r2 > 0.85) confidence = 'high';
            else if (r2 > 0.65) confidence = 'medium';

            let trend = 'stable';
            const slopeThreshold = sumY / n * 0.05;
            if (slope > slopeThreshold) trend = 'growing';
            else if (slope < -slopeThreshold) trend = 'declining';

            const avgSales = sumY / n;
            const prediction = Math.max(0, nextPrediction);
            const smoothedPrediction = prediction > avgSales * 2 ? avgSales * 1.5 : prediction;

            return {
                prediction: smoothedPrediction,
                confidence: confidence,
                trend: trend,
                slope: slope,
                r2: r2,
                modelType: 'linear',
                regressionLine: { slope, intercept }
            };
        }

        // Calculate R-squared for prediction confidence
        function calculateR2(actual, predicted) {
            if (actual.length === 0) return 0;

            const actualMean = actual.reduce((sum, val) => sum + val, 0) / actual.length;
            const totalSumSquares = actual.reduce((sum, val) => sum + Math.pow(val - actualMean, 2), 0);
            const residualSumSquares = actual.reduce((sum, val, i) => sum + Math.pow(val - predicted[i], 2), 0);

            if (totalSumSquares === 0) return 0;
            return Math.max(0, 1 - (residualSumSquares / totalSumSquares));
        }

        // Advanced trend analysis with seasonal detection
        function analyzeSeasonalTrends(shop) {
            const periods = window.timelinePeriods;
            if (!periods || periods.length < 6) return { seasonal: false, pattern: 'none' };

            const salesByMonth = {};
            periods.forEach(periodo => {
                const [year, month] = periodo.split('-');
                const monthNum = parseInt(month);
                if (!salesByMonth[monthNum]) salesByMonth[monthNum] = [];
                salesByMonth[monthNum].push(shop.data[periodo].sales);
            });

            // Check if we have data for multiple years in same months
            const monthsWithMultipleYears = Object.keys(salesByMonth).filter(month =>
                salesByMonth[month].length > 1
            );

            if (monthsWithMultipleYears.length < 3) return { seasonal: false, pattern: 'none' };

            // Calculate coefficient of variation for each month
            const monthlyVariation = {};
            monthsWithMultipleYears.forEach(month => {
                const values = salesByMonth[month];
                const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
                const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
                const stdDev = Math.sqrt(variance);
                monthlyVariation[month] = mean > 0 ? stdDev / mean : 0;
            });

            // Determine if pattern is seasonal (low variation within months, high between months)
            const avgVariation = Object.values(monthlyVariation).reduce((sum, val) => sum + val, 0) / Object.values(monthlyVariation).length;
            const seasonal = avgVariation < 0.3; // Less than 30% variation within months

            return {
                seasonal: seasonal,
                pattern: seasonal ? 'detected' : 'irregular',
                monthlyVariation: monthlyVariation
            };
        }

        // Generate prediction alerts and recommendations
        function generatePredictionAlerts() {
            const alerts = [];

            // Generate alerts from pivotData shops with predictions
            pivotData.forEach(shop => {
                if (!shop.prediction) return;
                const pred = shop.prediction;
                const shopName = getShopDisplayName(shop.shop);

                if (pred.confidence === 'high') {
                    if (pred.trend === 'growing') {
                        alerts.push({
                            type: 'success',
                            severity: 'info',
                            shop: shop.shop,
                            title: 'Crescita Sostenuta',
                            message: `Crescita sostenuta prevista (+${pred.slope > 0 ? (pred.slope * 100).toFixed(1) : '0'}% trend)`
                        });
                    } else if (pred.trend === 'declining') {
                        alerts.push({
                            type: 'warning',
                            severity: 'warning',
                            shop: shop.shop,
                            title: 'Tendenza al Declino',
                            message: `Tendenza al declino rilevata (${pred.slope < 0 ? (pred.slope * 100).toFixed(1) : '0'}% trend)`
                        });
                    }
                }

                // REMOVED: "Pattern Irregolare" alerts
                // For seasonal fashion business, irregular patterns are NORMAL
                // Low R² is expected due to seasonality variations

                // Only alert if prediction is unrealistically high/low
                if (pred.prediction > 0) {
                    const currentPeriodSales = getCurrentPeriodSales(shop);
                    if (currentPeriodSales > 0) {
                        const predictionRatio = pred.prediction / currentPeriodSales;

                        if (predictionRatio > 2.0) {
                            alerts.push({
                                type: 'warning',
                                severity: 'warning',
                                shop: shop.shop,
                                title: 'Predizione Molto Alta',
                                message: `Predizione ${(predictionRatio * 100).toFixed(0)}% sopra media attuale - verificare dati`
                            });
                        } else if (predictionRatio < 0.3) {
                            alerts.push({
                                type: 'warning',
                                severity: 'warning',
                                shop: shop.shop,
                                title: 'Predizione Molto Bassa',
                                message: `Predizione ${(100 - predictionRatio * 100).toFixed(0)}% sotto media attuale - possibile problema`
                            });
                        }
                    }
                }
            });

            return alerts;
        }

        // Helper function to get current period sales average for a shop
        function getCurrentPeriodSales(shop) {
            const periods = window.timelinePeriods;
            if (!periods || periods.length < 3) return 0;

            // Get last 3 months average as "current" baseline
            const recentPeriods = periods.slice(-3);
            const totalSales = recentPeriods.reduce((sum, period) =>
                sum + (shop.data[period] ? shop.data[period].sales : 0), 0);

            return totalSales / recentPeriods.length;
        }

        function renderResults() {
            renderStats();
            renderPivotTable();
            document.getElementById('results').classList.remove('hidden');

            // Auto-switch to results tab
            showTab('results');
            document.querySelector('.tab:nth-child(3)').classList.add('active');
            document.querySelectorAll('.tab').forEach((tab, index) => {
                if (index !== 2) tab.classList.remove('active');
            });
        }

        function renderStats() {
            const calculationMode = document.getElementById('calculationMode').value;
            const modeText = calculationMode === 'custom' ? 'Personalizzate' : 'Default';

            // Add filter info if present
            let filterDisplay = '';
            if (window.currentFilterInfo) {
                filterDisplay = `<div style="text-align: center; margin-bottom: 15px; padding: 10px; background: #e3f2fd; border-radius: 6px; color: #1976d2; font-weight: bold;">📊 ${window.currentFilterInfo.slice(0, -3)}</div>`;
            }

            if (window.isComparisonMode) {
                // Comparison mode stats
                const totalSalesA = pivotData.reduce((sum, shop) => sum + shop.salesA, 0);
                const totalSalesB = pivotData.reduce((sum, shop) => sum + shop.salesB, 0);
                const totalCommissionA = pivotData.reduce((sum, shop) => sum + shop.commissionA, 0);
                const totalCommissionB = pivotData.reduce((sum, shop) => sum + shop.commissionB, 0);
                const totalShops = pivotData.length;

                const salesGrowth = totalSalesA > 0 ? ((totalSalesB - totalSalesA) / totalSalesA) * 100 : 0;
                const commissionGrowth = totalCommissionA > 0 ? ((totalCommissionB - totalCommissionA) / totalCommissionA) * 100 : 0;

                const salesGrowthColor = salesGrowth >= 0 ? '#28a745' : '#dc3545';
                const commissionGrowthColor = commissionGrowth >= 0 ? '#28a745' : '#dc3545';
                const salesGrowthIcon = salesGrowth >= 0 ? '📈' : '📉';
                const commissionGrowthIcon = commissionGrowth >= 0 ? '📈' : '📉';

                document.getElementById('stats').innerHTML = filterDisplay + `
                    <div class="stat-card">
                        <div class="stat-value">${totalShops}</div>
                        <div>Negozi Analizzati</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">€${totalSalesA.toLocaleString('it-IT', {minimumFractionDigits: 2})}</div>
                        <div>Vendite Periodo A</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">€${totalSalesB.toLocaleString('it-IT', {minimumFractionDigits: 2})}</div>
                        <div>Vendite Periodo B</div>
                    </div>
                    <div class="stat-card" style="background: linear-gradient(135deg, ${salesGrowthColor}, ${salesGrowthColor}cc);">
                        <div class="stat-value">${salesGrowthIcon} ${salesGrowth > 0 ? '+' : ''}${salesGrowth.toFixed(1)}%</div>
                        <div>Crescita Vendite</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">€${totalCommissionA.toLocaleString('it-IT', {minimumFractionDigits: 2})}</div>
                        <div>Provvigioni A ${modeText}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">€${totalCommissionB.toLocaleString('it-IT', {minimumFractionDigits: 2})}</div>
                        <div>Provvigioni B ${modeText}</div>
                    </div>
                    <div class="stat-card" style="background: linear-gradient(135deg, ${commissionGrowthColor}, ${commissionGrowthColor}cc);">
                        <div class="stat-value">${commissionGrowthIcon} ${commissionGrowth > 0 ? '+' : ''}${commissionGrowth.toFixed(2)}%</div>
                        <div>Crescita Provvigioni</div>
                    </div>
                `;
            } else if (window.isTimelineMode) {
                // Timeline mode stats
                const totalShops = pivotData.length;
                const periods = window.timelinePeriods;

                // Calculate totals across all periods
                let totalSalesAllPeriods = 0;
                let totalCommissionAllPeriods = 0;

                pivotData.forEach(shop => {
                    totalSalesAllPeriods += shop.totalSales;
                    periods.forEach(periodo => {
                        totalCommissionAllPeriods += shop.data[periodo].commission;
                    });
                });

                // Calculate SIMPLE and USEFUL metrics only
                const simpleMetrics = calculateSimpleUsefulMetrics(pivotData, periods);

                // Find best and worst growth performers
                const bestGrowthShop = pivotData.reduce((best, current) =>
                    current.avgGrowth > best.avgGrowth ? current : best, pivotData[0]);
                const worstGrowthShop = pivotData.reduce((worst, current) =>
                    current.avgGrowth < worst.avgGrowth ? current : worst, pivotData[0]);

                const avgGrowthIcon = bestGrowthShop.avgGrowth >= 0 ? '📈' : '📉';
                const avgGrowthColor = bestGrowthShop.avgGrowth >= 0 ? '#28a745' : '#dc3545';

                // Generate prediction alerts for all shops
                const allPredictionAlerts = generatePredictionAlerts();
                const criticalAlerts = allPredictionAlerts.filter(alert => alert.severity === 'critical');
                const warningAlerts = allPredictionAlerts.filter(alert => alert.severity === 'warning');

                // Calculate prediction accuracy statistics
                let totalConfidence = 0;
                let highConfidencePredictions = 0;
                let lowConfidencePredictions = 0;
                pivotData.forEach(shop => {
                    const prediction = predictNextPeriod(shop);
                    if (prediction.confidence === 'high') highConfidencePredictions++;
                    else if (prediction.confidence === 'low') lowConfidencePredictions++;

                    const confidenceValue = prediction.confidence === 'high' ? 0.8 :
                                           prediction.confidence === 'medium' ? 0.6 : 0.3;
                    totalConfidence += confidenceValue;
                });
                const avgConfidence = totalShops > 0 ? (totalConfidence / totalShops * 100) : 0;

                // SIMPLE AND USEFUL DASHBOARD (3 core metrics only)
                const yoyColor = simpleMetrics.yoyGrowth >= 0 ? '#28a745' : '#dc3545';
                const yoyIcon = simpleMetrics.yoyGrowth >= 0 ? '📈' : '📉';

                const benchmarkColor = simpleMetrics.seasonalBenchmark?.status === 'above_normal' ? '#28a745' :
                                      simpleMetrics.seasonalBenchmark?.status === 'below_normal' ? '#dc3545' : '#6c757d';
                const benchmarkIcon = simpleMetrics.seasonalBenchmark?.status === 'above_normal' ? '🔥' :
                                     simpleMetrics.seasonalBenchmark?.status === 'below_normal' ? '❄️' : '✅';

                document.getElementById('stats').innerHTML = filterDisplay + `
                    <div class="stat-card" style="background: linear-gradient(135deg, ${yoyColor}, ${yoyColor}cc);">
                        <div class="stat-value">${yoyIcon} ${simpleMetrics.yoyGrowth > 0 ? '+' : ''}${simpleMetrics.yoyGrowth.toFixed(1)}%</div>
                        <div class="stat-label">Trend Anno/Anno (${simpleMetrics.availableComparisons} mesi)</div>
                        <div class="tooltip">Media di tutte le comparazioni mese-per-mese disponibili vs anno precedente. Molto più affidabile di un singolo mese. Basato su ${simpleMetrics.availableComparisons} confronti mensili.</div>
                    </div>
                    <div class="stat-card" style="background: linear-gradient(135deg, ${benchmarkColor}, ${benchmarkColor}cc);">
                        <div class="stat-value">${benchmarkIcon} ${simpleMetrics.seasonalBenchmark?.status || 'N/A'}</div>
                        <div class="stat-label">vs Benchmark Storico</div>
                        <div class="tooltip">Confronto con mediana degli ultimi ${simpleMetrics.seasonalBenchmark?.dataPoints || 0} anni stesso mese. Range normale: €${simpleMetrics.seasonalBenchmark ? (simpleMetrics.seasonalBenchmark.range[0]/1000).toFixed(0) : '0'}K - €${simpleMetrics.seasonalBenchmark ? (simpleMetrics.seasonalBenchmark.range[1]/1000).toFixed(0) : '0'}K</div>
                    </div>
                    <div class="stat-card" style="background: linear-gradient(135deg, #dc3545, #e74c3c);">
                        <div class="stat-value">⚠️ ${simpleMetrics.problemShops.length}</div>
                        <div class="stat-label">Negozi in Difficoltà</div>
                        <div class="tooltip">Negozi con calo >40% rispetto anno scorso - questi richiedono attenzione immediata</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${totalShops}</div>
                        <div class="stat-label">Negozi Totali</div>
                        <div class="tooltip">Numero di negozi analizzati</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${getShopDisplayName(simpleMetrics.topGrowingShop?.shop || '')}</div>
                        <div class="stat-label">Top Crescita: ${simpleMetrics.topGrowingShop ? '+' + simpleMetrics.topGrowingShop.yoyChange.toFixed(0) + '%' : 'N/A'}</div>
                        <div class="tooltip">Negozio con maggiore crescita anno su anno</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${getShopDisplayName(simpleMetrics.topDecliningShop?.shop || '')}</div>
                        <div class="stat-label">Maggiore Calo: ${simpleMetrics.topDecliningShop ? simpleMetrics.topDecliningShop.yoyChange.toFixed(0) + '%' : 'N/A'}</div>
                        <div class="tooltip">Negozio con maggiore calo anno su anno</div>
                    </div>
                `;

                // Add REAL problems alerts (not overengineered prediction stuff)
                if (simpleMetrics.problemShops.length > 0) {
                    const alertsHtml = `
                        <div style="margin-top: 20px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; padding: 15px;">
                            <h3 style="color: #856404; margin: 0 0 10px 0;">⚠️ Negozi che Richiedono Attenzione</h3>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 10px;">
                                ${simpleMetrics.problemShops.map(shop => `
                                    <div style="background: white; padding: 10px; border-radius: 6px; border-left: 4px solid #dc3545;">
                                        <strong>${getShopDisplayName(shop.shop)}</strong><br>
                                        <span style="color: #dc3545;">${shop.yoyChange.toFixed(1)}% vs anno scorso</span><br>
                                        <small>€${shop.current.toFixed(0)} vs €${shop.lastYear.toFixed(0)}</small>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                    document.getElementById('stats').innerHTML += alertsHtml;
                }

                // REMOVED: Complex prediction alerts that were useless for seasonal business
                if (false && allPredictionAlerts.length > 0) {
                    const alertsHtml = `
                        <div style="margin: 20px 0; padding: 15px; background: linear-gradient(135deg, #2d3436, #636e72); border-radius: 10px; color: white;">
                            <h3 style="margin: 0 0 15px 0; display: flex; align-items: center; gap: 10px;">
                                <span>🚨</span> Alert Predizioni
                            </h3>
                            <div class="prediction-alerts-container">
                                ${allPredictionAlerts.slice(0, 5).map(alert => `
                                    <div class="prediction-alert ${alert.severity}" style="
                                        padding: 10px 15px;
                                        margin: 8px 0;
                                        border-radius: 6px;
                                        border-left: 4px solid ${alert.severity === 'critical' ? '#e74c3c' : alert.severity === 'warning' ? '#f39c12' : '#3498db'};
                                        background: ${alert.severity === 'critical' ? 'rgba(231,76,60,0.1)' : alert.severity === 'warning' ? 'rgba(243,156,18,0.1)' : 'rgba(52,152,219,0.1)'};
                                        font-size: 12px;
                                        line-height: 1.4;
                                    ">
                                        <div style="font-weight: bold; margin-bottom: 4px;">
                                            ${alert.severity === 'critical' ? '🔴' : alert.severity === 'warning' ? '🟡' : '🔵'}
                                            ${getShopDisplayName(alert.shop)} - ${alert.title}
                                        </div>
                                        <div style="opacity: 0.9;">${alert.message}</div>
                                    </div>
                                `).join('')}
                                ${allPredictionAlerts.length > 5 ? `<div style="text-align: center; padding: 10px; opacity: 0.7; font-size: 11px;">... e altri ${allPredictionAlerts.length - 5} alert</div>` : ''}
                            </div>
                        </div>
                    `;
                    document.getElementById('stats').insertAdjacentHTML('beforeend', alertsHtml);
                }
            } else {
                // Single period mode (existing logic)
                const totalSales = pivotData.reduce((sum, shop) => sum + shop.totalSales, 0);
                const totalCommission = pivotData.reduce((sum, shop) => sum + shop.commission, 0);
                const totalOperators = pivotData.reduce((sum, shop) => sum + shop.operatorCount, 0);
                const totalShops = pivotData.length;

                document.getElementById('stats').innerHTML = filterDisplay + `
                    <div class="stat-card">
                        <div class="stat-value">${totalShops}</div>
                        <div>Negozi</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${totalOperators}</div>
                        <div>Operatori</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">€${totalSales.toLocaleString('it-IT', {minimumFractionDigits: 2})}</div>
                        <div>Venduto Totale</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">€${totalCommission.toLocaleString('it-IT', {minimumFractionDigits: 2})}</div>
                        <div>Provvigioni ${modeText}</div>
                    </div>
                `;
            }
        }


        function renderPivotTable() {
            if (window.isComparisonMode) {
                renderComparisonPivotTable();
            } else if (window.isTimelineMode) {
                renderTimelinePivotTable();
            } else {
                renderSinglePeriodPivotTable();
            }
        }

        function renderSinglePeriodPivotTable() {
            const container = document.getElementById('pivotContainer');
            if (pivotData.length === 0) {
                container.innerHTML = '<p style="text-align: center; padding: 40px; color: #666;">Nessun dato disponibile</p>';
                return;
            }
            let html = '';
            pivotData.forEach((shop, shopIndex) => {
                const shopDisplayName = getShopDisplayName(shop.shop);
                html += `
                    <div class="shop-row" data-shop="${shop.shop}" data-shop-name="${shopDisplayName.toLowerCase()}">
                        <div class="shop-header" onclick="toggleShop(${shopIndex})">
                            <div class="shop-info">
                                <div class="shop-name">🏪 ${shopDisplayName}</div>
                                <div class="shop-summary">
                                    ${shop.operatorCount} operatori • ${shop.transactions} transazioni
                                </div>
                            </div>
                            <div class="shop-metrics">
                                <div class="shop-metric">
                                    <div class="shop-metric-value">€${shop.totalSales.toLocaleString('it-IT', {minimumFractionDigits: 2})}</div>
                                    <div class="shop-metric-label">Venduto</div>
                                </div>
                                <div class="shop-metric">
                                    <div class="shop-metric-value">€${shop.commission.toLocaleString('it-IT', {minimumFractionDigits: 2})}</div>
                                    <div class="shop-metric-label">Provvigioni</div>
                                </div>
                                <div class="shop-metric">
                                    <div class="shop-metric-value">€${shop.avgPerOperator.toLocaleString('it-IT', {minimumFractionDigits: 2})}</div>
                                    <div class="shop-metric-label">Media Operatore</div>
                                </div>
                                <div class="expand-icon">▶</div>
                            </div>
                        </div>
                        <div class="operators-table">
                            <table>
                                <thead>
                                    <tr>
                                        <th style="text-align: center;">Pos.</th>
                                        <th>👤 Operatore</th>
                                        <th>⚙️ % Rate</th>
                                        <th>💰 Venduto (€)</th>
                                        <th>🏆 Provvigione (€)</th>
                                        <th>📊 % nel Negozio</th>
                                        <th>🔢 Transazioni</th>
                                    </tr>
                                </thead>
                                <tbody>`;
                shop.operators.forEach((operator, index) => {
                    let rowClass = '';
                    let position = '';
                    if (index === 0) {
                        rowClass = 'operator-rank-1';
                        position = '🥇';
                    } else if (index === 1) {
                        rowClass = 'operator-rank-2';
                        position = '🥈';
                    } else if (index === 2) {
                        rowClass = 'operator-rank-3';
                        position = '🥉';
                    } else {
                        position = `${index + 1}°`;
                    }
                    if (operator.isCustomRate) {
                        rowClass += ' custom-rate';
                    }
                    const rateDisplay = operator.isCustomRate ?
                        `<strong>${(operator.rate * 100).toFixed(2)}%</strong> ⚙️` :
                        `${(operator.rate * 100).toFixed(2)}%`;
                    html += `
                        <tr class="${rowClass}">
                            <td class="text-center"><strong>${position}</strong></td>
                            <td><strong>${operator.operatore}</strong></td>
                            <td class="text-center">${rateDisplay}</td>
                            <td class="currency">${operator.totalSales.toLocaleString('it-IT', {minimumFractionDigits: 2})}</td>
                            <td class="currency">${operator.commission.toLocaleString('it-IT', {minimumFractionDigits: 2})}</td>
                            <td class="percentage">${operator.percentageInShop.toFixed(2)}%</td>
                            <td class="text-center">${operator.transactions}</td>
                        </tr>
                    `;
                });
                html += `
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }

        function renderComparisonPivotTable() {
            const container = document.getElementById('pivotContainer');
            if (pivotData.length === 0) {
                container.innerHTML = '<p style="text-align: center; padding: 40px; color: #666;">Nessun dato disponibile</p>';
                return;
            }

            const periodA = document.getElementById('periodFilterA').selectedOptions[0]?.text || 'Periodo A';
            const periodB = document.getElementById('periodFilterB').selectedOptions[0]?.text || 'Periodo B';

            let html = '';
            pivotData.forEach((shop, shopIndex) => {
                const shopDisplayName = getShopDisplayName(shop.shop);
                const salesGrowth = shop.salesA > 0 ? ((shop.salesB - shop.salesA) / shop.salesA) * 100 : (shop.salesB > 0 ? 100 : 0);
                const commissionGrowth = shop.commissionA > 0 ? ((shop.commissionB - shop.commissionA) / shop.commissionA) * 100 : (shop.commissionB > 0 ? 100 : 0);

                const salesGrowthColor = salesGrowth >= 0 ? '#28a745' : '#dc3545';
                const commissionGrowthColor = commissionGrowth >= 0 ? '#28a745' : '#dc3545';
                const salesGrowthIcon = salesGrowth >= 0 ? '📈' : '📉';
                const commissionGrowthIcon = commissionGrowth >= 0 ? '📈' : '📉';

                html += `
                    <div class="shop-row comparison-mode" data-shop="${shop.shop}" data-shop-name="${shopDisplayName.toLowerCase()}">
                        <div class="shop-header" onclick="toggleShop(${shopIndex})">
                            <div class="shop-info">
                                <div class="shop-name">🏪 ${shopDisplayName}</div>
                                <div class="shop-summary">
                                    ${Math.max((shop.operatorsA?.length || 0), (shop.operatorsB?.length || 0))} operatori attivi
                                </div>
                            </div>
                            <div class="shop-metrics">
                                <div class="comparison-metrics">
                                    <div class="period-comparison">
                                        <div class="period-label">${periodA}</div>
                                        <div class="period-values">
                                            <div>€${shop.salesA.toLocaleString('it-IT', {minimumFractionDigits: 2})}</div>
                                            <div>€${shop.commissionA.toLocaleString('it-IT', {minimumFractionDigits: 2})}</div>
                                        </div>
                                    </div>
                                    <div class="period-comparison">
                                        <div class="period-label">${periodB}</div>
                                        <div class="period-values">
                                            <div>€${shop.salesB.toLocaleString('it-IT', {minimumFractionDigits: 2})}</div>
                                            <div>€${shop.commissionB.toLocaleString('it-IT', {minimumFractionDigits: 2})}</div>
                                        </div>
                                    </div>
                                    <div class="growth-indicators">
                                        <div class="growth-metric" style="color: ${salesGrowthColor};">
                                            ${salesGrowthIcon} ${salesGrowth > 0 ? '+' : ''}${salesGrowth.toFixed(1)}%
                                        </div>
                                        <div class="growth-metric" style="color: ${commissionGrowthColor};">
                                            ${commissionGrowthIcon} ${commissionGrowth > 0 ? '+' : ''}${commissionGrowth.toFixed(2)}%
                                        </div>
                                    </div>
                                </div>
                                <div class="expand-icon">▶</div>
                            </div>
                        </div>
                        <div class="operators-table">
                            <table>
                                <thead>
                                    <tr>
                                        <th rowspan="2" style="text-align: center; vertical-align: middle; color: white;">👤 Operatore</th>
                                        <th colspan="3" style="text-align: center; background: #1565c0; color: white; font-weight: bold;">${periodA}</th>
                                        <th colspan="3" style="text-align: center; background: #bf360c; color: white; font-weight: bold;">${periodB}</th>
                                        <th rowspan="2" style="text-align: center; vertical-align: middle; color: white;">📈 Crescita</th>
                                    </tr>
                                    <tr>
                                        <th style="background: #1976d2; color: white; font-weight: bold;">💰 Venduto</th>
                                        <th style="background: #1976d2; color: white; font-weight: bold;">🏆 Provvigione</th>
                                        <th style="background: #1976d2; color: white; font-weight: bold;">🔢 Trans.</th>
                                        <th style="background: #d32f2f; color: white; font-weight: bold;">💰 Venduto</th>
                                        <th style="background: #d32f2f; color: white; font-weight: bold;">🏆 Provvigione</th>
                                        <th style="background: #d32f2f; color: white; font-weight: bold;">🔢 Trans.</th>
                                    </tr>
                                </thead>
                                <tbody>`;

                // Get all operators from both periods
                const allOperators = new Set([
                    ...(shop.operatorsA || []).map(op => op.operatore),
                    ...(shop.operatorsB || []).map(op => op.operatore)
                ]);

                // Create combined operator data for comparison
                const combinedOperators = Array.from(allOperators).map(operatorName => {
                    const opA = (shop.operatorsA || []).find(op => op.operatore === operatorName);
                    const opB = (shop.operatorsB || []).find(op => op.operatore === operatorName);

                    const salesA = opA ? opA.totalSales : 0;
                    const salesB = opB ? opB.totalSales : 0;
                    const commissionA = opA ? opA.commission : 0;
                    const commissionB = opB ? opB.commission : 0;
                    const transactionsA = opA ? opA.transactions : 0;
                    const transactionsB = opB ? opB.transactions : 0;

                    const growthPercent = salesA > 0 ? ((salesB - salesA) / salesA) * 100 : (salesB > 0 ? 100 : 0);

                    return {
                        operatore: operatorName,
                        salesA, salesB, commissionA, commissionB,
                        transactionsA, transactionsB, growthPercent,
                        totalSales: salesA + salesB, // For sorting
                        isCustomRate: (opA && opA.isCustomRate) || (opB && opB.isCustomRate)
                    };
                }).sort((a, b) => b.totalSales - a.totalSales);

                combinedOperators.forEach((operator, index) => {
                    const growthColor = operator.growthPercent >= 0 ? '#28a745' : '#dc3545';
                    const growthIcon = operator.growthPercent >= 0 ? '📈' : '📉';

                    let rowClass = '';
                    if (operator.isCustomRate) {
                        rowClass += 'custom-rate ';
                    }

                    // Highlight significant changes
                    if (Math.abs(operator.growthPercent) > 20) {
                        rowClass += 'significant-change ';
                    }

                    html += `
                        <tr class="${rowClass}">
                            <td><strong style="color: #1a1a1a;">${operator.operatore}</strong></td>
                            <td class="currency" style="background: #e3f2fd; color: #0d47a1; font-weight: bold;">€${operator.salesA.toLocaleString('it-IT', {minimumFractionDigits: 2})}</td>
                            <td class="currency" style="background: #e3f2fd; color: #0d47a1; font-weight: bold;">€${operator.commissionA.toLocaleString('it-IT', {minimumFractionDigits: 2})}</td>
                            <td class="text-center" style="background: #e3f2fd; color: #0d47a1; font-weight: bold;">${operator.transactionsA}</td>
                            <td class="currency" style="background: #fff3e0; color: #bf360c; font-weight: bold;">€${operator.salesB.toLocaleString('it-IT', {minimumFractionDigits: 2})}</td>
                            <td class="currency" style="background: #fff3e0; color: #bf360c; font-weight: bold;">€${operator.commissionB.toLocaleString('it-IT', {minimumFractionDigits: 2})}</td>
                            <td class="text-center" style="background: #fff3e0; color: #bf360c; font-weight: bold;">${operator.transactionsB}</td>
                            <td class="text-center" style="color: ${growthColor}; font-weight: bold; background: #f8f9fa;">
                                ${growthIcon} ${operator.growthPercent > 0 ? '+' : ''}${operator.growthPercent.toFixed(1)}%
                            </td>
                        </tr>
                    `;
                });

                html += `
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }

        function renderTimelinePivotTable() {
            const container = document.getElementById('pivotContainer');
            if (pivotData.length === 0) {
                container.innerHTML = '<p style="text-align: center; padding: 40px; color: #666;">Nessun dato disponibile</p>';
                return;
            }

            const periods = window.timelinePeriods;

            let html = '';
            pivotData.forEach((shop, shopIndex) => {
                const shopDisplayName = getShopDisplayName(shop.shop);
                const avgGrowthColor = shop.avgGrowth >= 0 ? '#28a745' : '#dc3545';
                const avgGrowthIcon = shop.avgGrowth >= 0 ? '📈' : '📉';

                html += `
                    <div class="shop-row timeline-mode" data-shop="${shop.shop}" data-shop-name="${shopDisplayName.toLowerCase()}">
                        <div class="shop-header" onclick="toggleShop(${shopIndex})">
                            <div class="shop-info">
                                <div class="shop-name">🏪 ${shopDisplayName}</div>
                                <div class="shop-summary">
                                    ${periods.length} periodi • Trend: ${avgGrowthIcon} ${shop.avgGrowth > 0 ? '+' : ''}${shop.avgGrowth.toFixed(1)}% • Predizione: ${shop.prediction.confidence}
                                </div>
                            </div>
                            <div class="timeline-summary" style="color: ${avgGrowthColor};">
                                <div class="timeline-metric">
                                    <div class="timeline-value">€${shop.totalSales.toLocaleString('it-IT', {minimumFractionDigits: 2})}</div>
                                    <div class="timeline-label">Totale Periodo</div>
                                </div>
                                <div class="timeline-trend">
                                    <div class="trend-indicator" style="color: ${avgGrowthColor};">
                                        ${avgGrowthIcon} ${shop.avgGrowth > 0 ? '+' : ''}${shop.avgGrowth.toFixed(1)}%
                                    </div>
                                    <div class="timeline-label">Crescita Media</div>
                                </div>
                                <div class="timeline-trend">
                                    <div class="trend-indicator" style="color: ${shop.yoyGrowth >= 0 ? '#28a745' : '#dc3545'};">
                                        ${shop.yoyGrowth >= 0 ? '📊' : '📉'} ${shop.yoyGrowth > 0 ? '+' : ''}${shop.yoyGrowth.toFixed(1)}%
                                    </div>
                                    <div class="timeline-label">Trend YoY</div>
                                </div>
                                <div class="expand-icon">▶</div>
                            </div>
                        </div>
                        <div class="operators-table">
                            <div class="timeline-chart-container">
                                <h4 style="text-align: center; margin: 15px 0;">📊 Andamento Temporale - ${shopDisplayName}</h4>
                                <div class="prediction-info" style="text-align: center; margin: 10px 0; padding: 8px; background: #f8f9fa; border-radius: 4px; font-size: 12px;">
                                    <span style="font-weight: bold;">Predizione Prossimo Periodo:</span>
                                    <span style="color: ${shop.prediction.confidence === 'high' ? '#28a745' : shop.prediction.confidence === 'medium' ? '#ffc107' : '#6c757d'};">
                                        €${shop.prediction.prediction.toLocaleString('it-IT', {minimumFractionDigits: 0})}
                                        (${shop.prediction.confidence === 'high' ? '🎯 Alta' : shop.prediction.confidence === 'medium' ? '📊 Media' : '❓ Bassa'} confidenza)
                                        ${shop.prediction.modelType === 'seasonal-fashion' ?
                                            `<br><span style="font-size: 11px; opacity: 0.8; color: #e67e22; font-weight: bold;">🌟 Modello Stagionale (Fattore: ${shop.prediction.seasonalFactor?.toFixed(2)}x, R²: ${(shop.prediction.r2 * 100)?.toFixed(0)}%)</span>` :
                                            `<br><span style="font-size: 11px; opacity: 0.8; color: #34495e;">📊 Modello Lineare (R²: ${(shop.prediction.r2 * 100)?.toFixed(0)}%)</span>`
                                        }
                                    </span>
                                    ${shop.prediction.trend === 'growing' ? '<span style="color: #28a745;">📈 Crescita</span>' :
                                      shop.prediction.trend === 'declining' ? '<span style="color: #dc3545;">📉 Declino</span>' :
                                      '<span style="color: #6c757d;">➡️ Stabile</span>'}
                                </div>
                                <div class="timeline-chart" id="chart-${shopIndex}"></div>
                            </div>
                            <table>
                                <thead>
                                    <tr>
                                        <th style="text-align: center;">📅 Periodo</th>
                                        <th>💰 Vendite (€)</th>
                                        <th>🏆 Provvigioni (€)</th>
                                        <th>👥 Operatori</th>
                                        <th>🔢 Transazioni</th>
                                        <th>📈 Crescita vs Prec.</th>
                                    </tr>
                                </thead>
                                <tbody>`;

                periods.forEach((periodo, periodIndex) => {
                    const data = shop.data[periodo];
                    const [year, month] = periodo.split('-');
                    const monthNames = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu',
                                      'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'];
                    const monthName = monthNames[parseInt(month) - 1];

                    // Calculate growth vs previous period
                    let growth = 0;
                    let growthDisplay = '-';
                    if (periodIndex > 0) {
                        const prevPeriod = periods[periodIndex - 1];
                        const prevData = shop.data[prevPeriod];
                        if (prevData.sales > 0) {
                            growth = ((data.sales - prevData.sales) / prevData.sales) * 100;
                            const growthIcon = growth >= 0 ? '📈' : '📉';
                            const growthColor = growth >= 0 ? '#28a745' : '#dc3545';
                            growthDisplay = `<span style="color: ${growthColor}; font-weight: bold;">${growthIcon} ${growth > 0 ? '+' : ''}${growth.toFixed(1)}%</span>`;
                        }
                    }

                    html += `
                        <tr ${data.sales === 0 ? 'style="opacity: 0.6;"' : ''}>
                            <td class="text-center"><strong>${monthName} ${year}</strong></td>
                            <td class="currency">${data.sales.toLocaleString('it-IT', {minimumFractionDigits: 2})}</td>
                            <td class="currency">${data.commission.toLocaleString('it-IT', {minimumFractionDigits: 2})}</td>
                            <td class="text-center">${data.operators}</td>
                            <td class="text-center">${data.transactions}</td>
                            <td class="text-center">${growthDisplay}</td>
                        </tr>
                    `;
                });

                html += `
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;

            // Generate mini charts for each shop
            pivotData.forEach((shop, shopIndex) => {
                createMiniTimelineChart(shop, shopIndex);
            });
        }

        // Create mini timeline chart for each shop
        function createMiniTimelineChart(shop, shopIndex) {
            const chartContainer = document.getElementById(`chart-${shopIndex}`);
            if (!chartContainer) return;

            const periods = window.timelinePeriods;
            const salesData = periods.map(p => shop.data[p].sales);

            // Include prediction in max calculation for proper scaling
            const prediction = shop.prediction ? shop.prediction.prediction : 0;
            const maxSales = Math.max(...salesData, prediction);

            let chartHtml = '<div class="mini-chart">';

            // Historical data bars
            periods.forEach((periodo, index) => {
                const data = shop.data[periodo];
                const [year, month] = periodo.split('-');
                const monthNames = ['G', 'F', 'M', 'A', 'M', 'G', 'L', 'A', 'S', 'O', 'N', 'D'];
                const monthName = monthNames[parseInt(month) - 1];
                const height = maxSales > 0 ? (data.sales / maxSales) * 80 : 0;

                chartHtml += `
                    <div class="chart-bar">
                        <div class="chart-column" style="height: ${height}px;" title="€${data.sales.toLocaleString('it-IT')}"></div>
                        <div class="chart-label">${monthName}${year.slice(-2)}</div>
                    </div>
                `;
            });

            // Add prediction bar if available
            if (shop.prediction && shop.prediction.prediction > 0) {
                const predictionHeight = maxSales > 0 ? (prediction / maxSales) * 80 : 0;
                const confidenceColor = shop.prediction.confidence === 'high' ? '#28a745' :
                                      shop.prediction.confidence === 'medium' ? '#ffc107' : '#6c757d';

                // Calculate next period label
                const lastPeriod = periods[periods.length - 1];
                const [lastYear, lastMonth] = lastPeriod.split('-');
                const nextMonth = parseInt(lastMonth) + 1;
                const nextYear = nextMonth > 12 ? parseInt(lastYear) + 1 : parseInt(lastYear);
                const finalMonth = nextMonth > 12 ? 1 : nextMonth;
                const monthNames = ['G', 'F', 'M', 'A', 'M', 'G', 'L', 'A', 'S', 'O', 'N', 'D'];
                const nextLabel = monthNames[finalMonth - 1] + String(nextYear).slice(-2);

                chartHtml += `
                    <div class="chart-bar prediction-bar">
                        <div class="chart-column prediction-column"
                             style="height: ${predictionHeight}px;
                                    background: linear-gradient(to top, ${confidenceColor}, ${confidenceColor}aa);
                                    border: 2px dashed ${confidenceColor};"
                             title="Predizione: €${prediction.toLocaleString('it-IT')} (${shop.prediction.confidence})"></div>
                        <div class="chart-label prediction-label">${nextLabel}</div>
                    </div>
                `;
            }

            chartHtml += '</div>';
            chartContainer.innerHTML = chartHtml;
        }

        function toggleShop(shopIndex) {
            const shopRow = document.querySelectorAll('.shop-row')[shopIndex];
            const isExpanded = shopRow.classList.contains('expanded');

            if (isExpanded) {
                shopRow.classList.remove('expanded');
            } else {
                shopRow.classList.add('expanded');
            }
        }

        function toggleAllShops() {
            const shopRows = document.querySelectorAll('.shop-row');
            allExpanded = !allExpanded;

            shopRows.forEach(row => {
                if (allExpanded) {
                    row.classList.add('expanded');
                } else {
                    row.classList.remove('expanded');
                }
            });

            document.querySelector('.btn-expand').textContent =
                allExpanded ? '📕 Chiudi Tutto' : '📖 Espandi Tutto';
        }

        function filterPivotTable() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const shopRows = document.querySelectorAll('.shop-row');

            shopRows.forEach(row => {
                const shopCode = row.getAttribute('data-shop').toLowerCase();
                const shopName = row.getAttribute('data-shop-name').toLowerCase();
                const operatorCells = row.querySelectorAll('.operators-table tbody tr td:nth-child(2)');
                let hasMatchingOperator = false;

                operatorCells.forEach(cell => {
                    if (cell.textContent.toLowerCase().includes(searchTerm)) {
                        hasMatchingOperator = true;
                    }
                });

                if (shopCode.includes(searchTerm) || shopName.includes(searchTerm) || hasMatchingOperator || searchTerm === '') {
                    row.style.display = 'block';
                } else {
                    row.style.display = 'none';
                }
            });
        }

        function sortPivotTable() {
            const sortBy = document.getElementById('sortSelect').value;
            let sortedData = [...pivotData];

            switch (sortBy) {
                case 'commission':
                    sortedData.sort((a, b) => b.commission - a.commission);
                    break;
                case 'sales':
                    sortedData.sort((a, b) => b.totalSales - a.totalSales);
                    break;
                case 'operators':
                    sortedData.sort((a, b) => b.operatorCount - a.operatorCount);
                    break;
                case 'name':
                    sortedData.sort((a, b) => a.shop.localeCompare(b.shop));
                    break;
            }

            pivotData = sortedData;
            renderPivotTable();
        }

        function filterRatesTable() {
            const searchTerm = document.getElementById('employeeSearch').value.toLowerCase();
            const shopFilter = document.getElementById('employeeShopFilter').value;
            const ratesFilter = document.getElementById('ratesFilter').value;

            const tbody = document.getElementById('ratesTableBody');
            const rows = tbody.querySelectorAll('tr');

            let visibleRows = 0;

            rows.forEach(row => {
                const operatorName = row.cells[0].textContent.toLowerCase();
                const operatorShopDisplay = row.cells[1].textContent;
                const hasCustomRate = row.classList.contains('custom-rate');

                // Extract shop code from the display name to match filter
                let operatorShopCode = '';
                // Find shop code by reverse lookup from display name
                Object.keys(operatorTotals).forEach(opName => {
                    const op = operatorTotals[opName];
                    if (row.cells[0].textContent === op.operatore) {
                        operatorShopCode = op.codDep;
                    }
                });

                // Check search term
                const matchesSearch = searchTerm === '' || operatorName.includes(searchTerm);

                // Check shop filter
                const matchesShop = shopFilter === '' || operatorShopCode === shopFilter;

                // Check rates filter
                let matchesRatesFilter = true;
                if (ratesFilter === 'custom') {
                    matchesRatesFilter = hasCustomRate;
                } else if (ratesFilter === 'default') {
                    matchesRatesFilter = !hasCustomRate;
                }

                if (matchesSearch && matchesShop && matchesRatesFilter) {
                    row.style.display = '';
                    visibleRows++;
                } else {
                    row.style.display = 'none';
                }
            });

            // Show/hide "no results" message
            const container = document.getElementById('ratesTableContainer');
            let noResultsMsg = container.querySelector('.no-results-message');

            if (visibleRows === 0 && rows.length > 0) {
                if (!noResultsMsg) {
                    noResultsMsg = document.createElement('div');
                    noResultsMsg.className = 'no-results-message';
                    noResultsMsg.style.cssText = 'text-align: center; padding: 40px; color: #666; font-style: italic;';
                    noResultsMsg.innerHTML = '🔍 Nessun dipendente trovato con i filtri attuali';
                    container.appendChild(noResultsMsg);
                }
                noResultsMsg.style.display = 'block';
            } else if (noResultsMsg) {
                noResultsMsg.style.display = 'none';
            }
        }

        function clearFilters() {
            document.getElementById('employeeSearch').value = '';
            document.getElementById('employeeShopFilter').value = '';
            document.getElementById('ratesFilter').value = 'all';
            filterRatesTable();
        }

        // PDF Export functionality
        function exportToPDF() {
            if (pivotData.length === 0) {
                alert('Nessun dato da esportare. Elabora prima i dati!');
                return;
            }

            if (window.isComparisonMode) {
                exportComparisonToPDF();
            } else if (window.isTimelineMode) {
                exportTimelineToPDF();
            } else {
                exportSinglePeriodToPDF();
            }
        }

        // Single period PDF export (existing functionality)
        function exportSinglePeriodToPDF() {
            // Initialize jsPDF
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('p', 'mm', 'a4');

            // Helper function to clean text from problematic characters
            function cleanText(text) {
                return text
                    .replace(/📊/g, '[CHART]')
                    .replace(/📈/g, '[TREND]')
                    .replace(/🏪/g, '[SHOP]')
                    .replace(/🥇/g, '1°')
                    .replace(/🥈/g, '2°')
                    .replace(/🥉/g, '3°')
                    .replace(/📝/g, '[NOTE]')
                    .replace(/⭐/g, '[STAR]')
                    .replace(/⚙️/g, '*')
                    .replace(/€/g, 'EUR ')
                    .replace(/à/g, 'a\'')
                    .replace(/è/g, 'e\'')
                    .replace(/é/g, 'e\'')
                    .replace(/ì/g, 'i\'')
                    .replace(/ò/g, 'o\'')
                    .replace(/ù/g, 'u\'');
            }

            // Get current date and calculation mode
            const currentDate = new Date().toLocaleDateString('it-IT');
            const calculationMode = document.getElementById('calculationMode').value;
            const modeText = calculationMode === 'custom' ? 'Personalizzate' : 'Default';

            // Calculate totals
            const totalSales = pivotData.reduce((sum, shop) => sum + shop.totalSales, 0);
            const totalCommission = pivotData.reduce((sum, shop) => sum + shop.commission, 0);
            const totalOperators = pivotData.reduce((sum, shop) => sum + shop.operatorCount, 0);
            const totalShops = pivotData.length;

            // PDF Header
            doc.setFontSize(20);
            doc.setFont(undefined, 'bold');
            doc.text(cleanText('[CHART] ANALISI VENDITE - REPORT DETTAGLIATO'), 105, 20, { align: 'center' });

            doc.setFontSize(12);
            doc.setFont(undefined, 'normal');
            doc.text(cleanText(`Data Generazione: ${currentDate}`), 20, 30);
            doc.text(cleanText(`Modalita\' Calcolo: Percentuali ${modeText}`), 20, 36);

            // Summary Statistics
            doc.setFontSize(14);
            doc.setFont(undefined, 'bold');
            doc.text(cleanText('[TREND] RIEPILOGO GENERALE'), 20, 50);

            doc.setFontSize(10);
            doc.setFont(undefined, 'normal');
            const summaryY = 58;
            doc.text(cleanText(`Negozi Analizzati: ${totalShops}`), 20, summaryY);
            doc.text(cleanText(`Operatori Totali: ${totalOperators}`), 20, summaryY + 6);
            doc.text(cleanText(`Venduto Totale: EUR ${totalSales.toLocaleString('it-IT', {minimumFractionDigits: 2})}`), 20, summaryY + 12);
            doc.text(cleanText(`Provvigioni Totali: EUR ${totalCommission.toLocaleString('it-IT', {minimumFractionDigits: 2})}`), 20, summaryY + 18);

            // Line separator
            doc.setLineWidth(0.5);
            doc.line(20, summaryY + 25, 190, summaryY + 25);

            let currentY = summaryY + 35;

            // TOP 10 Global Performers Section
            doc.setFontSize(14);
            doc.setFont(undefined, 'bold');
            doc.text(cleanText('[STAR] TOP 10 VENDITORI GLOBALI'), 20, currentY);
            currentY += 10;

            // Collect all operators from all shops for global ranking
            const allOperators = [];
            pivotData.forEach(shop => {
                shop.operators.forEach(operator => {
                    allOperators.push({
                        operatore: operator.operatore,
                        shopCode: shop.shop,
                        shopName: getShopDisplayName(shop.shop),
                        totalSales: operator.totalSales,
                        commission: operator.commission,
                        rate: operator.rate,
                        isCustomRate: operator.isCustomRate,
                        transactions: operator.transactions
                    });
                });
            });

            // Sort by total sales and take top 10
            const top10Global = allOperators
                .sort((a, b) => b.totalSales - a.totalSales)
                .slice(0, 10);

            // Create TOP 10 table data
            const top10TableData = [];
            top10Global.forEach((operator, index) => {
                const position = index + 1;
                let positionDisplay = `${position}°`;
                if (position === 1) positionDisplay = `1° [GOLD]`;
                else if (position === 2) positionDisplay = `2° [SILVER]`;
                else if (position === 3) positionDisplay = `3° [BRONZE]`;

                const rateDisplay = operator.isCustomRate ?
                    `${(operator.rate * 100).toFixed(2)}% *` :
                    `${(operator.rate * 100).toFixed(2)}%`;

                top10TableData.push([
                    positionDisplay,
                    cleanText(operator.operatore),
                    cleanText(operator.shopName),
                    rateDisplay,
                    `EUR ${operator.totalSales.toLocaleString('it-IT', {minimumFractionDigits: 2})}`,
                    `EUR ${operator.commission.toLocaleString('it-IT', {minimumFractionDigits: 2})}`,
                    operator.transactions.toString()
                ]);
            });

            // Add TOP 10 table
            doc.autoTable({
                startY: currentY,
                head: [['Pos.', 'Operatore', 'Negozio', '% Rate', 'Venduto (EUR)', 'Provvigione (EUR)', 'Trans.']],
                body: top10TableData,
                theme: 'grid',
                headStyles: {
                    fillColor: [255, 193, 7], // Golden color for global ranking
                    textColor: [0, 0, 0],
                    fontSize: 9,
                    fontStyle: 'bold'
                },
                bodyStyles: {
                    fontSize: 8,
                    cellPadding: 3
                },
                columnStyles: {
                    0: { halign: 'center', cellWidth: 20 }, // Position
                    1: { cellWidth: 35 }, // Operatore
                    2: { cellWidth: 30 }, // Negozio
                    3: { halign: 'center', cellWidth: 18 }, // Rate
                    4: { halign: 'right', cellWidth: 30 }, // Venduto
                    5: { halign: 'right', cellWidth: 30 }, // Provvigione
                    6: { halign: 'center', cellWidth: 15 } // Transazioni
                },
                margin: { left: 20, right: 20 },
                didDrawCell: function (data) {
                    // Highlight top 3 global performers
                    if (data.section === 'body') {
                        const rowIndex = data.row.index;
                        if (rowIndex === 0) {
                            data.cell.styles.fillColor = [255, 215, 0, 0.5]; // Gold
                            data.cell.styles.fontStyle = 'bold';
                        } else if (rowIndex === 1) {
                            data.cell.styles.fillColor = [192, 192, 192, 0.5]; // Silver
                            data.cell.styles.fontStyle = 'bold';
                        } else if (rowIndex === 2) {
                            data.cell.styles.fillColor = [205, 127, 50, 0.5]; // Bronze
                            data.cell.styles.fontStyle = 'bold';
                        }
                    }
                }
            });

            currentY = doc.lastAutoTable.finalY + 20;

            // Add some info about the global ranking
            doc.setFontSize(8);
            doc.setFont(undefined, 'italic');
            doc.text(cleanText('Nota: Classifica basata sul venduto totale di ciascun operatore'), 20, currentY);
            currentY += 15;

            // Line separator before shop details
            doc.setLineWidth(0.5);
            doc.line(20, currentY, 190, currentY);
            currentY += 10;

            // Iterate through each shop
            pivotData.forEach((shop, shopIndex) => {
                // Check if we need a new page
                if (currentY > 250) {
                    doc.addPage();
                    currentY = 20;
                }

                const shopDisplayName = getShopDisplayName(shop.shop);

                // Shop Header
                doc.setFontSize(12);
                doc.setFont(undefined, 'bold');
                doc.text(cleanText(`[SHOP] ${shopDisplayName}`), 20, currentY);

                doc.setFontSize(10);
                doc.setFont(undefined, 'normal');
                doc.text(cleanText(`${shop.operatorCount} operatori - ${shop.transactions} transazioni`), 20, currentY + 6);
                doc.text(cleanText(`Venduto: EUR ${shop.totalSales.toLocaleString('it-IT', {minimumFractionDigits: 2})} - ` +
                         `Provvigioni: EUR ${shop.commission.toLocaleString('it-IT', {minimumFractionDigits: 2})}`), 20, currentY + 12);

                currentY += 20;

                // Operators table for this shop
                const tableData = [];
                shop.operators.forEach((operator, index) => {
                    const position = index === 0 ? '1°' : index === 1 ? '2°' : index === 2 ? '3°' : `${index + 1}°`;
                    const rateDisplay = operator.isCustomRate ? `${(operator.rate * 100).toFixed(2)}% *` : `${(operator.rate * 100).toFixed(2)}%`;

                    tableData.push([
                        position,
                        cleanText(operator.operatore),
                        rateDisplay,
                        `EUR ${operator.totalSales.toLocaleString('it-IT', {minimumFractionDigits: 2})}`,
                        `EUR ${operator.commission.toLocaleString('it-IT', {minimumFractionDigits: 2})}`,
                        `${operator.percentageInShop.toFixed(2)}%`,
                        operator.transactions.toString()
                    ]);
                });

                // Auto table for operators
                doc.autoTable({
                    startY: currentY,
                    head: [['Pos.', 'Operatore', '% Rate', 'Venduto (EUR)', 'Provvigione (EUR)', '% Negozio', 'Trans.']],
                    body: tableData,
                    theme: 'striped',
                    headStyles: {
                        fillColor: [76, 175, 80],
                        textColor: [255, 255, 255],
                        fontSize: 8,
                        fontStyle: 'bold'
                    },
                    bodyStyles: {
                        fontSize: 8,
                        cellPadding: 2
                    },
                    columnStyles: {
                        0: { halign: 'center', cellWidth: 15 }, // Position
                        1: { cellWidth: 40 }, // Operatore
                        2: { halign: 'center', cellWidth: 20 }, // Rate
                        3: { halign: 'right', cellWidth: 25 }, // Venduto
                        4: { halign: 'right', cellWidth: 25 }, // Provvigione
                        5: { halign: 'center', cellWidth: 20 }, // % Negozio
                        6: { halign: 'center', cellWidth: 15 } // Transazioni
                    },
                    margin: { left: 20, right: 20 },
                    didDrawCell: function (data) {
                        // Highlight top 3 performers
                        if (data.section === 'body') {
                            const rowIndex = data.row.index;
                            if (rowIndex === 0) {
                                doc.setFillColor(255, 215, 0, 0.3); // Gold
                            } else if (rowIndex === 1) {
                                doc.setFillColor(192, 192, 192, 0.3); // Silver
                            } else if (rowIndex === 2) {
                                doc.setFillColor(205, 127, 50, 0.3); // Bronze
                            }
                        }
                    }
                });

                currentY = doc.lastAutoTable.finalY + 10;

                // Add some spacing between shops
                if (shopIndex < pivotData.length - 1) {
                    currentY += 5;
                }
            });

            // Footer with legend
            doc.addPage();
            doc.setFontSize(12);
            doc.setFont(undefined, 'bold');
            doc.text(cleanText('[NOTE] LEGENDA E NOTE'), 20, 30);

            doc.setFontSize(10);
            doc.setFont(undefined, 'normal');
            doc.text(cleanText('* = Percentuale personalizzata applicata'), 20, 45);
            doc.text(cleanText('1° 2° 3° = Top 3 performers per negozio'), 20, 52);
            doc.text(cleanText('[GOLD] [SILVER] [BRONZE] = Top 3 venditori globali'), 20, 59);
            doc.text(cleanText('% Negozio = Percentuale delle vendite dell\'operatore sul totale del negozio'), 20, 66);
            doc.text(cleanText('[SHOP] = Indica sezione negozio'), 20, 73);
            doc.text(cleanText('[STAR] = Classifica globale venditori'), 20, 80);
            doc.text(cleanText('[CHART] = Report di analisi vendite'), 20, 87);
            doc.text(cleanText('EUR = Valuta Euro'), 20, 94);

            doc.setFontSize(8);
            doc.setTextColor(128);
            doc.text(cleanText('Generato automaticamente dall\'Analizzatore Vendite'), 105, 280, { align: 'center' });

            // Generate filename with current date
            const filename = `analisi-vendite-${new Date().toISOString().split('T')[0]}.pdf`;

            // Save the PDF
            doc.save(filename);

            // Show success message
            setTimeout(() => {
                alert(`Report PDF generato con successo!\n\nFile: ${filename}\n\nDettagli inclusi:\n• ${totalShops} negozi analizzati\n• ${totalOperators} operatori\n• Vendite totali: EUR ${totalSales.toLocaleString('it-IT')}\n• Provvigioni ${modeText.toLowerCase()}`);
            }, 500);
        }

        // Comparison mode PDF export
        function exportComparisonToPDF() {
            // Initialize jsPDF
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('p', 'mm', 'a4');

            // Helper function to clean text from problematic characters
            function cleanText(text) {
                return text
                    .replace(/📊/g, '[CHART]')
                    .replace(/📈/g, '[TREND_UP]')
                    .replace(/📉/g, '[TREND_DOWN]')
                    .replace(/🏪/g, '[SHOP]')
                    .replace(/🥇/g, '1°')
                    .replace(/🥈/g, '2°')
                    .replace(/🥉/g, '3°')
                    .replace(/📝/g, '[NOTE]')
                    .replace(/⭐/g, '[STAR]')
                    .replace(/⚙️/g, '*')
                    .replace(/€/g, 'EUR ')
                    .replace(/à/g, 'a\'')
                    .replace(/è/g, 'e\'')
                    .replace(/é/g, 'e\'')
                    .replace(/ì/g, 'i\'')
                    .replace(/ò/g, 'o\'')
                    .replace(/ù/g, 'u\'');
            }

            // Get current date and calculation mode
            const currentDate = new Date().toLocaleDateString('it-IT');
            const calculationMode = document.getElementById('calculationMode').value;
            const modeText = calculationMode === 'custom' ? 'Personalizzate' : 'Default';

            // Get period information
            const periodA = window.periodA;
            const periodB = window.periodB;
            const [yearA, monthA] = periodA.split('-');
            const [yearB, monthB] = periodB.split('-');
            const monthNames = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu',
                              'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'];
            const monthNameA = monthNames[parseInt(monthA) - 1];
            const monthNameB = monthNames[parseInt(monthB) - 1];

            // Calculate comparison totals
            const totalSalesA = pivotData.reduce((sum, shop) => sum + shop.salesA, 0);
            const totalSalesB = pivotData.reduce((sum, shop) => sum + shop.salesB, 0);
            const totalCommissionA = pivotData.reduce((sum, shop) => sum + shop.commissionA, 0);
            const totalCommissionB = pivotData.reduce((sum, shop) => sum + shop.commissionB, 0);
            const totalShops = pivotData.length;

            const salesGrowth = totalSalesA > 0 ? ((totalSalesB - totalSalesA) / totalSalesA) * 100 : 0;
            const commissionGrowth = totalCommissionA > 0 ? ((totalCommissionB - totalCommissionA) / totalCommissionA) * 100 : 0;

            // PDF Header
            doc.setFontSize(20);
            doc.setFont(undefined, 'bold');
            doc.text(cleanText('[CHART] ANALISI COMPARATIVA VENDITE'), 105, 20, { align: 'center' });

            doc.setFontSize(12);
            doc.setFont(undefined, 'normal');
            doc.text(cleanText(`Data Generazione: ${currentDate}`), 20, 30);
            doc.text(cleanText(`Modalita\' Calcolo: Percentuali ${modeText}`), 20, 36);
            doc.text(cleanText(`Confronto: ${monthNameA} ${yearA} vs ${monthNameB} ${yearB}`), 20, 42);

            // Summary Statistics
            doc.setFontSize(14);
            doc.setFont(undefined, 'bold');
            doc.text(cleanText('[TREND_UP] RIEPILOGO COMPARATIVO'), 20, 58);

            doc.setFontSize(10);
            doc.setFont(undefined, 'normal');
            const summaryY = 66;

            doc.text(cleanText(`Negozi Analizzati: ${totalShops}`), 20, summaryY);
            doc.text(cleanText(`Periodo A (${monthNameA} ${yearA}):`), 20, summaryY + 8);
            doc.text(cleanText(`  • Vendite: EUR ${totalSalesA.toLocaleString('it-IT', {minimumFractionDigits: 2})}`), 25, summaryY + 14);
            doc.text(cleanText(`  • Provvigioni: EUR ${totalCommissionA.toLocaleString('it-IT', {minimumFractionDigits: 2})}`), 25, summaryY + 20);

            doc.text(cleanText(`Periodo B (${monthNameB} ${yearB}):`), 20, summaryY + 28);
            doc.text(cleanText(`  • Vendite: EUR ${totalSalesB.toLocaleString('it-IT', {minimumFractionDigits: 2})}`), 25, summaryY + 34);
            doc.text(cleanText(`  • Provvigioni: EUR ${totalCommissionB.toLocaleString('it-IT', {minimumFractionDigits: 2})}`), 25, summaryY + 40);

            // Growth indicators
            const salesTrendIcon = salesGrowth >= 0 ? '[TREND_UP]' : '[TREND_DOWN]';
            const commissionTrendIcon = commissionGrowth >= 0 ? '[TREND_UP]' : '[TREND_DOWN]';

            doc.setFont(undefined, 'bold');
            doc.text(cleanText(`CRESCITA VENDITE: ${salesTrendIcon} ${salesGrowth > 0 ? '+' : ''}${salesGrowth.toFixed(1)}%`), 20, summaryY + 50);
            doc.text(cleanText(`CRESCITA PROVVIGIONI: ${commissionTrendIcon} ${commissionGrowth > 0 ? '+' : ''}${commissionGrowth.toFixed(2)}%`), 20, summaryY + 56);

            // Line separator
            doc.setLineWidth(0.5);
            doc.line(20, summaryY + 65, 190, summaryY + 65);

            let currentY = summaryY + 75;

            // Summary table for all shops comparison
            doc.setFontSize(14);
            doc.setFont(undefined, 'bold');
            doc.text(cleanText('[SHOP] CONFRONTO PER NEGOZIO'), 20, currentY);
            currentY += 10;

            // Create comparison table data
            const comparisonTableData = [];
            pivotData.forEach((shop, index) => {
                const shopDisplayName = getShopDisplayName(shop.shop);
                const salesGrowthShop = shop.salesA > 0 ? ((shop.salesB - shop.salesA) / shop.salesA) * 100 : (shop.salesB > 0 ? 100 : 0);
                const trendIcon = salesGrowthShop >= 0 ? '[TREND_UP]' : '[TREND_DOWN]';

                comparisonTableData.push([
                    cleanText(shopDisplayName),
                    `EUR ${shop.salesA.toLocaleString('it-IT', {minimumFractionDigits: 2})}`,
                    `EUR ${shop.salesB.toLocaleString('it-IT', {minimumFractionDigits: 2})}`,
                    cleanText(`${trendIcon} ${salesGrowthShop > 0 ? '+' : ''}${salesGrowthShop.toFixed(1)}%`),
                    `EUR ${shop.commissionA.toLocaleString('it-IT', {minimumFractionDigits: 2})}`,
                    `EUR ${shop.commissionB.toLocaleString('it-IT', {minimumFractionDigits: 2})}`
                ]);
            });

            // Add comparison table
            doc.autoTable({
                startY: currentY,
                head: [[
                    'Negozio',
                    `Vendite ${monthNameA}`,
                    `Vendite ${monthNameB}`,
                    'Crescita',
                    `Prov. ${monthNameA}`,
                    `Prov. ${monthNameB}`
                ]],
                body: comparisonTableData,
                theme: 'grid',
                headStyles: {
                    fillColor: [76, 175, 80], // Green for comparison
                    textColor: [255, 255, 255],
                    fontSize: 9,
                    fontStyle: 'bold'
                },
                bodyStyles: {
                    fontSize: 8,
                    cellPadding: 2
                },
                columnStyles: {
                    0: { cellWidth: 35 }, // Negozio
                    1: { halign: 'right', cellWidth: 28 }, // Vendite A
                    2: { halign: 'right', cellWidth: 28 }, // Vendite B
                    3: { halign: 'center', cellWidth: 25 }, // Crescita
                    4: { halign: 'right', cellWidth: 24 }, // Prov A
                    5: { halign: 'right', cellWidth: 24 } // Prov B
                },
                margin: { left: 20, right: 20 },
                willDrawCell: function (data) {
                    // Color code growth cells BEFORE drawing
                    if (data.section === 'body' && data.column.index === 3) {
                        const cellText = data.cell.text[0] || '';
                        if (cellText.includes('[TREND_UP]')) {
                            data.cell.styles.textColor = [34, 139, 34]; // Dark green
                            data.cell.styles.fontStyle = 'bold';
                        } else if (cellText.includes('[TREND_DOWN]')) {
                            data.cell.styles.textColor = [220, 20, 60]; // RED for negative
                            data.cell.styles.fontStyle = 'bold';
                        }
                    }
                }
            });

            currentY = doc.lastAutoTable.finalY + 15;

            // Top performers comparison section
            if (currentY > 220) {
                doc.addPage();
                currentY = 20;
            }

            doc.setFontSize(14);
            doc.setFont(undefined, 'bold');
            doc.text(cleanText('[STAR] TOP PERFORMERS COMPARISON'), 20, currentY);
            currentY += 10;

            // Get top performers from both periods
            const topPerformersA = [];
            const topPerformersB = [];

            pivotData.forEach(shop => {
                if (shop.operatorsA) {
                    shop.operatorsA.slice(0, 3).forEach(op => {
                        topPerformersA.push({
                            operatore: op.operatore,
                            shop: getShopDisplayName(shop.shop),
                            sales: op.totalSales,
                            commission: op.commission
                        });
                    });
                }
                if (shop.operatorsB) {
                    shop.operatorsB.slice(0, 3).forEach(op => {
                        topPerformersB.push({
                            operatore: op.operatore,
                            shop: getShopDisplayName(shop.shop),
                            sales: op.totalSales,
                            commission: op.commission
                        });
                    });
                }
            });

            // Sort and take top 10 for each period
            topPerformersA.sort((a, b) => b.sales - a.sales);
            topPerformersB.sort((a, b) => b.sales - a.sales);

            const top10A = topPerformersA.slice(0, 10);
            const top10B = topPerformersB.slice(0, 10);

            // Create side-by-side top performers table
            const topPerformersTableData = [];
            const maxRows = Math.max(top10A.length, top10B.length);

            for (let i = 0; i < maxRows; i++) {
                const performerA = top10A[i];
                const performerB = top10B[i];

                topPerformersTableData.push([
                    performerA ? `${i + 1}°` : '',
                    performerA ? cleanText(performerA.operatore) : '',
                    performerA ? `EUR ${performerA.sales.toLocaleString('it-IT', {minimumFractionDigits: 2})}` : '',
                    performerB ? `${i + 1}°` : '',
                    performerB ? cleanText(performerB.operatore) : '',
                    performerB ? `EUR ${performerB.sales.toLocaleString('it-IT', {minimumFractionDigits: 2})}` : ''
                ]);
            }

            // Add top performers comparison table
            doc.autoTable({
                startY: currentY,
                head: [[
                    'Pos.', `Top ${monthNameA}`, 'Vendite',
                    'Pos.', `Top ${monthNameB}`, 'Vendite'
                ]],
                body: topPerformersTableData,
                theme: 'grid',
                headStyles: {
                    fillColor: [255, 152, 0], // Orange for top performers
                    textColor: [255, 255, 255],
                    fontSize: 9,
                    fontStyle: 'bold'
                },
                bodyStyles: {
                    fontSize: 8,
                    cellPadding: 2
                },
                columnStyles: {
                    0: { halign: 'center', cellWidth: 15 }, // Pos A
                    1: { cellWidth: 40 }, // Name A
                    2: { halign: 'right', cellWidth: 30 }, // Sales A
                    3: { halign: 'center', cellWidth: 15 }, // Pos B
                    4: { cellWidth: 40 }, // Name B
                    5: { halign: 'right', cellWidth: 30 } // Sales B
                },
                margin: { left: 20, right: 20 }
            });

            currentY = doc.lastAutoTable.finalY + 15;

            // Add analysis notes
            doc.setFontSize(8);
            doc.setFont(undefined, 'italic');
            doc.text(cleanText('Note:'), 20, currentY);
            doc.text(cleanText('• [TREND_UP] indica crescita positiva, [TREND_DOWN] indica decrescita'), 20, currentY + 6);
            doc.text(cleanText('• La classifica e\' basata sul venduto totale per ogni operatore'), 20, currentY + 12);
            doc.text(cleanText('• * indica percentuali personalizzate'), 20, currentY + 18);

            // Generate filename with comparison info
            const filename = `confronto-vendite-${monthNameA}${yearA}-vs-${monthNameB}${yearB}-${new Date().toISOString().split('T')[0]}.pdf`;

            // Save the PDF
            doc.save(filename);

            // Show success message
            setTimeout(() => {
                alert(`Report Comparativo PDF generato con successo!\n\nFile: ${filename}\n\nConfronto incluso:\n• Periodo A: ${monthNameA} ${yearA} (EUR ${totalSalesA.toLocaleString('it-IT')})\n• Periodo B: ${monthNameB} ${yearB} (EUR ${totalSalesB.toLocaleString('it-IT')})\n• Crescita Vendite: ${salesGrowth.toFixed(1)}%\n• Crescita Provvigioni: ${commissionGrowth.toFixed(2)}%`);
            }, 500);
        }

        // Timeline mode PDF export with red negative percentages
        function exportTimelineToPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('p', 'mm', 'a4');

            // Helper function to clean text from problematic characters
            function cleanText(text) {
                return text
                    .replace(/📊/g, '[CHART]')
                    .replace(/📈/g, '[TREND_UP]')
                    .replace(/📉/g, '[TREND_DOWN]')
                    .replace(/🏪/g, '[SHOP]')
                    .replace(/🥇/g, '1°')
                    .replace(/🥈/g, '2°')
                    .replace(/🥉/g, '3°')
                    .replace(/📝/g, '[NOTE]')
                    .replace(/⭐/g, '[STAR]')
                    .replace(/⚙️/g, '*')
                    .replace(/€/g, 'EUR ')
                    .replace(/à/g, 'a\'')
                    .replace(/è/g, 'e\'')
                    .replace(/é/g, 'e\'')
                    .replace(/ì/g, 'i\'')
                    .replace(/ò/g, 'o\'')
                    .replace(/ù/g, 'u\'');
            }

            const currentDate = new Date().toLocaleDateString('it-IT');
            const calculationMode = document.getElementById('calculationMode').value;
            const modeText = calculationMode === 'custom' ? 'Personalizzate' : 'Default';
            const periods = window.timelinePeriods;

            // PDF Header
            doc.setFontSize(20);
            doc.setFont(undefined, 'bold');
            doc.text(cleanText('[CHART] ANALISI TIMELINE VENDITE'), 105, 20, { align: 'center' });

            doc.setFontSize(12);
            doc.setFont(undefined, 'normal');
            doc.text(cleanText(`Data Generazione: ${currentDate}`), 20, 30);
            doc.text(cleanText(`Modalita\' Calcolo: Percentuali ${modeText}`), 20, 36);
            doc.text(cleanText(`Periodi Analizzati: ${periods.length} (da ${periods[0]} a ${periods[periods.length - 1]})`), 20, 42);

            let currentY = 58;

            // Summary Statistics
            doc.setFontSize(14);
            doc.setFont(undefined, 'bold');
            doc.text(cleanText('[TREND_UP] RIEPILOGO TIMELINE'), 20, currentY);
            currentY += 10;

            // Calculate timeline totals
            let totalSalesAllPeriods = 0;
            let totalCommissionAllPeriods = 0;
            pivotData.forEach(shop => {
                totalSalesAllPeriods += shop.totalSales;
                periods.forEach(periodo => {
                    totalCommissionAllPeriods += shop.data[periodo].commission;
                });
            });

            doc.setFontSize(10);
            doc.setFont(undefined, 'normal');
            doc.text(cleanText(`Negozi Analizzati: ${pivotData.length}`), 20, currentY + 6);
            doc.text(cleanText(`Vendite Cumulative: EUR ${totalSalesAllPeriods.toLocaleString('it-IT', {minimumFractionDigits: 2})}`), 20, currentY + 12);
            doc.text(cleanText(`Provvigioni Cumulative: EUR ${totalCommissionAllPeriods.toLocaleString('it-IT', {minimumFractionDigits: 2})}`), 20, currentY + 18);

            // Line separator
            doc.setLineWidth(0.5);
            doc.line(20, currentY + 30, 190, currentY + 30);
            currentY += 40;

            // Timeline table for shops
            doc.setFontSize(14);
            doc.setFont(undefined, 'bold');
            doc.text(cleanText('[SHOP] ANDAMENTO TEMPORALE PER NEGOZIO'), 20, currentY);
            currentY += 10;

            // Create timeline table with growth percentages
            const timelineTableData = [];
            pivotData.forEach(shop => {
                const shopDisplayName = getShopDisplayName(shop.shop);

                // Get first and last period data for overall growth
                const firstPeriod = periods[0];
                const lastPeriod = periods[periods.length - 1];
                const firstSales = shop.data[firstPeriod].sales;
                const lastSales = shop.data[lastPeriod].sales;
                const overallGrowth = firstSales > 0 ? ((lastSales - firstSales) / firstSales) * 100 : 0;
                const trendIcon = overallGrowth >= 0 ? '[TREND_UP]' : '[TREND_DOWN]';

                timelineTableData.push([
                    cleanText(shopDisplayName),
                    `EUR ${firstSales.toLocaleString('it-IT', {minimumFractionDigits: 2})}`,
                    `EUR ${lastSales.toLocaleString('it-IT', {minimumFractionDigits: 2})}`,
                    cleanText(`${trendIcon} ${overallGrowth > 0 ? '+' : ''}${overallGrowth.toFixed(1)}%`),
                    `EUR ${shop.data[firstPeriod].commission.toLocaleString('it-IT', {minimumFractionDigits: 2})}`,
                    `EUR ${shop.data[lastPeriod].commission.toLocaleString('it-IT', {minimumFractionDigits: 2})}`
                ]);
            });

            // Add timeline table
            doc.autoTable({
                startY: currentY,
                head: [[
                    'Negozio',
                    `Vendite Inizio (${periods[0]})`,
                    `Vendite Fine (${periods[periods.length - 1]})`,
                    'Crescita Totale',
                    'Prov. Inizio',
                    'Prov. Fine'
                ]],
                body: timelineTableData,
                theme: 'grid',
                headStyles: {
                    fillColor: [76, 175, 80],
                    textColor: [255, 255, 255],
                    fontSize: 9,
                    fontStyle: 'bold'
                },
                bodyStyles: {
                    fontSize: 8,
                    cellPadding: 2
                },
                columnStyles: {
                    0: { cellWidth: 32 },
                    1: { halign: 'right', cellWidth: 28 },
                    2: { halign: 'right', cellWidth: 28 },
                    3: { halign: 'center', cellWidth: 26 },
                    4: { halign: 'right', cellWidth: 24 },
                    5: { halign: 'right', cellWidth: 24 }
                },
                margin: { left: 20, right: 20 },
                willDrawCell: function (data) {
                    // Color code growth cells - RED FOR NEGATIVE!
                    if (data.section === 'body' && data.column.index === 3) {
                        const cellText = data.cell.text[0] || '';
                        if (cellText.includes('[TREND_UP]')) {
                            data.cell.styles.textColor = [34, 139, 34]; // Dark green
                            data.cell.styles.fontStyle = 'bold';
                        } else if (cellText.includes('[TREND_DOWN]')) {
                            data.cell.styles.textColor = [220, 20, 60]; // RED for negative
                            data.cell.styles.fontStyle = 'bold';
                        }
                    }
                }
            });

            currentY = doc.lastAutoTable.finalY + 15;

            // Add prediction alerts if available
            if (typeof generatePredictionAlerts === 'function') {
                const predictionAlerts = generatePredictionAlerts();
                if (predictionAlerts.length > 0) {
                    if (currentY > 220) {
                        doc.addPage();
                        currentY = 20;
                    }

                    doc.setFontSize(14);
                    doc.setFont(undefined, 'bold');
                    doc.text(cleanText('[STAR] ALERT PREDIZIONI'), 20, currentY);
                    currentY += 10;

                    doc.setFontSize(9);
                    doc.setFont(undefined, 'normal');

                    predictionAlerts.slice(0, 8).forEach(alert => {
                        const shopName = getShopDisplayName(alert.shop);
                        const alertText = cleanText(`• ${shopName}: ${alert.title} - ${alert.message}`);
                        doc.text(alertText, 20, currentY);
                        currentY += 6;
                    });
                }
            }

            // Generate filename
            const startPeriod = periods[0].replace('-', '');
            const endPeriod = periods[periods.length - 1].replace('-', '');
            const filename = `timeline-vendite-${startPeriod}-${endPeriod}-${new Date().toISOString().split('T')[0]}.pdf`;

            // Save the PDF
            doc.save(filename);

            // Show success message
            setTimeout(() => {
                alert(`Report Timeline PDF generato con successo!\n\nFile: ${filename}\n\nPeriodi inclusi: ${periods.length}\nRange: ${periods[0]} - ${periods[periods.length - 1]}\nVendite totali: EUR ${totalSalesAllPeriods.toLocaleString('it-IT')}`);
            }, 500);
        }
    </script>
</body>
</html>